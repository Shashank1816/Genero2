{\rtf1\ansi\ansicpg1252\cocoartf2706
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \{******************************************************************************\
*                                                                             *\
*    Filename     :   por1100c.4gl                                            *\
*                                                                             *\
*    System       :   Eunice 4GL                                              *\
*                                                                             *\
*    Purpose      :   STOCK MAINTENANCE                                       *\
*                      (Sales Modelling / Replenish days / Admin Alloc Stock) *\
*                                                                             *\
*    Author       :   CANNOT_SHOW                                         *\
*                                                                             *\
*    Date Written :   May, 2005                                               *\
*                                                                             *\
*******************************************************************************\}\
\
GLOBALS\
    "por1100gbl.4gl"\
\
\{******************************************************************************\}\
\
TYPE t_replenishDays DYNAMIC ARRAY OF RECORD\
        deliveryGroupId      INTEGER,\
        salesPerson     LIKE whse_delivery_zone_branch.wdzb_salesperson_code,\
        mon             LIKE repl_days.srd_mon,\
        tue             LIKE repl_days.srd_tue,\
        wed             LIKE repl_days.srd_wed,\
        thu             LIKE repl_days.srd_thu,\
        fri             LIKE repl_days.srd_fri,\
        sat             LIKE repl_days.srd_sat,\
        sun             LIKE repl_days.srd_sun\
     END RECORD,\
     t_supplierProductGroupRepDays RECORD\
            srd_suppno                 LIKE repl_days.srd_suppno,\
            spname                          CHAR(60),\
            srd_repno                  LIKE repl_days.srd_repno,\
            srd_mon                    LIKE repl_days.srd_mon,\
            srd_tue                    LIKE repl_days.srd_tue,\
            srd_wed                    LIKE repl_days.srd_wed,\
            srd_thu                    LIKE repl_days.srd_thu,\
            srd_fri                    LIKE repl_days.srd_fri,\
            srd_sat                    LIKE repl_days.srd_sat,\
            srd_sun                    LIKE repl_days.srd_sun,\
            srd_status                 LIKE repl_days.srd_status,\
            srd_balance                LIKE repl_days.srd_balance,\
            delivery_group             LIKE whse_delivery_group.wdg_id\
     END RECORD\
\
FUNCTION show_stats(l_stats)\
\
 DEFINE l_stats RECORD\
            optcnt                      SMALLINT,\
            optperc                     DECIMAL(4,1),\
            ovrcnt                      SMALLINT,\
            ovrperc                     DECIMAL(4,1),\
            lowcnt                      SMALLINT,\
            lowperc                     DECIMAL(4,1),\
            stockavail                  DECIMAL(4,1),\
            ooscnt                      SMALLINT,\
            oosperc                     DECIMAL(4,1),\
            numord                      INTEGER,\
            ordper_mth                  DECIMAL(4,1)\
        END RECORD,\
        l_notused                       SMALLINT\
\
 DEFINE l_show_stats_msg1             STRING,\
        l_show_stats_msg2             STRING,\
        l_show_stats_msg3             STRING\
\
    LET l_show_stats_msg1 = SFMT("\\n                                        Count              %%\\nOptimum                              %1          %2\\nOverstock                            %3          %4\\nLow                                      %5          %6\\n                                            -----          -----\\nStock Availability                                  %7\\n                                            -----          -----\\nOut Of Stock                      %8        %9\\n",\
                            l_stats.optcnt USING "####&",\
                            l_stats.optperc USING "##&.&%",\
                            l_stats.ovrcnt USING "####&",\
                            l_stats.ovrperc USING "##&.&%",\
                            l_stats.lowcnt USING "####&",\
                            l_stats.lowperc USING "##&.&%",\
                            l_stats.stockavail USING "##&.&%",\
                            l_stats.ooscnt USING "####&",\
                            l_stats.oosperc USING "##&.&%")\
\
\
    LET l_show_stats_msg2 = SFMT("\\nNo. of Orders                       %1\\nAvg Orders per Month        %2",l_stats.numord USING "####&", l_stats.ordper_mth USING "##&.&")\
\
    LET l_show_stats_msg3 = l_show_stats_msg1, l_show_stats_msg2\
\
    CALL lib_info_message_window("Replenish Statistics",l_show_stats_msg3)\
\
    LET l_notused = TRUE\
\
    CALL check_del("") RETURNING l_notused\
\
END FUNCTION\
\
\{******************************************************************************\}\
\
FUNCTION replenish_days()\
\
 DEFINE l_hdr RECORD\
            brcode                                      LIKE branch.brcode,\
            brname                                      LIKE branch.brname,\
            sprepcode                                   LIKE salesperson.sprepcode,\
            sprepname                                   LIKE salesperson.sprepname\
        END RECORD ,\
        l_query                                              CHAR(300),\
        l_rd RECORD                                     LIKE repl_days.*,\
        l_idx                                                SMALLINT,\
        l_supplierProductGroupRepDays DYNAMIC ARRAY OF       t_supplierProductGroupRepDays,\
        l_replenishDays                                      t_replenishDays,\
        l_record_count                                       SMALLINT,\
        l_previousSupplier RECORD\
            suppno                                      LIKE repl_days.srd_suppno,\
            suppname                                         CHAR(60)\
        END RECORD,\
        l_old_repno                                     LIKE repl_days.srd_repno,\
        l_insert                                             SMALLINT,\
        l_cont, l_print                                      SMALLINT,\
        l_bal_found                                          SMALLINT,\
        l_whse_found                                         SMALLINT,\
        l_notused                                            CHAR(1),\
        l_ok, l_arr, l_scr                                   SMALLINT,\
        l_toggle                                             SMALLINT,\
        i, j                                                 SMALLINT,\
        l_brstate                                       LIKE branch.brstate,\
        l_message                                            STRING,\
        l_pickingScheduleBranches DYNAMIC ARRAY OF      LIKE branch.brcode,\
        l_defaultReplDays                                    SMALLINT,\
        l_supplierReplDays                                   SMALLINT,\
        l_allowedReplDays                                    SMALLINT,\
        l_dummy                                              INTEGER\
 \
    CALL lib_tag_event("SM_430")           \{ Request # 25619\}\
    OPEN WINDOW repldaywin WITH FORM "por1100_replenishDays2"\
    CALL lib_set_form_toolbar("Array")\
\
    CALL lib_get_branchApplicationControl("REPLENISH_DAYS", "")\
         RETURNING l_defaultReplDays, l_dummy\
\
    CALL lib_get_branchApplicationControl("REPLENISH_DAYS", p_uid.idbranch)\
         RETURNING l_supplierReplDays, l_dummy\
\
    -- Query main settings\
    WHILE(TRUE)\
\
        DELETE FROM tmp_repl\
        INITIALIZE l_hdr, l_supplierProductGroupRepDays TO NULL\
        IF p_uid.idtype != "H" THEN\
\
            -- Determine true stock branch\
            CALL std_get_stock_branch(p_uid.idbranch, 0, 0, "G")\
                 RETURNING l_notused, l_hdr.brcode, l_notused\
                         -- ^ Sell     ^ Stock\
\
            LET l_hdr.brname = lib_get_branchName(l_hdr.brcode)\
            LET l_brstate = lib_get_branch_state(l_hdr.brcode)\
            DISPLAY BY NAME l_hdr.brname                  \
        END IF\
        LET l_ok = TRUE\
        LET l_toggle = FALSE\
\
        INPUT BY NAME l_hdr.brcode, l_hdr.sprepcode WITHOUT DEFAULTS\
                                       \
\
            BEFORE FIELD brcode\
                IF p_uid.idtype != "H" THEN\
                    NEXT FIELD sprepcode\
                END IF\
\
            AFTER FIELD brcode\
                IF LENGTH(l_hdr.brcode) = 0 THEN\
                    ERROR " Branch Code must be entered! "\
                    NEXT FIELD brcode\
                END IF\
                IF LENGTH(l_hdr.brcode) > 0 THEN\
                    -- Determine true stock branch\
                    CALL std_get_stock_branch(l_hdr.brcode, 0, 0, "G")\
                         RETURNING l_notused, l_hdr.brcode, l_notused\
                                 -- ^ Sell     ^ Stock\
                    IF NOT lib_check_existsInBranchTable(l_hdr.brcode) THEN\
                        DISPLAY "" TO brname\
                        ERROR " Invalid branch code! "\
                        NEXT FIELD brcode\
                    END IF\
                    LET l_hdr.brname = lib_get_branchName(l_hdr.brcode)\
                    LET l_brstate = lib_get_branch_state(l_hdr.brcode)\
                    DISPLAY BY NAME l_hdr.brname                  \
                END IF\
\
            AFTER FIELD sprepcode\
                IF LENGTH(l_hdr.sprepcode) > 0 THEN\
                    IF std_isSalespersonEnabled(l_hdr.brcode, l_hdr.sprepcode) THEN\
                        CALL lib_get_salespersonName(l_hdr.brcode, l_hdr.sprepcode)\
                            RETURNING l_hdr.sprepname\
                    ELSE\
                        ERROR " Invalid Salesperson Code! "\
                        DISPLAY "" TO sprepname\
                        NEXT FIELD sprepcode\
                    END IF\
                    DISPLAY BY NAME l_hdr.sprepname                  \
                END IF\
\
             ON ACTION branch_search INFIELD brcode \{F1\}\
                    IF branch_win("") THEN\
                        LET l_hdr.brcode = p_bsel.brcode\
                        IF NOT lib_check_existsInBranchTable(l_hdr.brcode) THEN\
                            DISPLAY "" TO brname\
                            ERROR " Invalid branch code! "\
                            NEXT FIELD brcode\
                        END IF\
                        LET l_hdr.brname = lib_get_branchName(l_hdr.brcode)\
                        LET l_brstate = lib_get_branch_state(l_hdr.brcode)\
                        DISPLAY BY NAME l_hdr.brcode, l_hdr.brname\
                    END IF\
\
             ON ACTION salesperson_search INFIELD sprepcode \{F1\}\
                    CALL std_selectSalesperson(l_hdr.brcode, NULL, NULL)\
                        RETURNING l_hdr.sprepcode, l_hdr.sprepname\
                    IF LENGTH(l_hdr.sprepcode) = 0 THEN\
                        ERROR " Invalid Salesperson Code! "\
                        DISPLAY "" TO sprepname\
                        NEXT FIELD sprepcode\
                    END IF\
                    DISPLAY BY NAME l_hdr.sprepcode, l_hdr.sprepname\
                                             \
\
            AFTER INPUT\
                IF check_del("") THEN\
                    LET l_ok = FALSE\
                    EXIT INPUT\
                END IF\
                IF LENGTH(l_hdr.brcode) > 0 AND\
                   p_uid.idtype = "H" THEN\
                    IF NOT lib_check_existsInBranchTable(l_hdr.brcode) THEN\
                        DISPLAY "" TO brname\
                        ERROR " Invalid branch code! "\
                        NEXT FIELD brcode\
                    END IF\
                    LET l_hdr.brname = lib_get_branchName(l_hdr.brcode)\
                    LET l_brstate = lib_get_branch_state(l_hdr.brcode)\
                    DISPLAY BY NAME l_hdr.brname                  \
                END IF\
                IF LENGTH(l_hdr.sprepcode) > 0 THEN\
                    IF std_isSalespersonEnabled(l_hdr.brcode, l_hdr.sprepcode) THEN\
                        CALL lib_get_salespersonName(l_hdr.brcode, l_hdr.sprepcode)\
                            RETURNING l_hdr.sprepname\
                    ELSE\
                        ERROR " Invalid Salesperson Code! "\
                        DISPLAY "" TO sprepname\
                        NEXT FIELD sprepcode\
                    END IF\
                    DISPLAY BY NAME l_hdr.sprepname                  \
                END IF\
\
        END INPUT\
\
        IF NOT l_ok THEN\
            EXIT WHILE\
        END IF\
\
        LET l_record_count = 1\
        LET l_bal_found = FALSE\
        LET l_whse_found = FALSE\
\
        CALL std_getBranchArrayPickingScheduleAllowed()\
            RETURNING l_pickingScheduleBranches\
 \
        -- Get up to date details for warehouse replenishment.\
        FOR i = 1 TO l_pickingScheduleBranches.getLength()\
            LET l_supplierProductGroupRepDays[1].delivery_group = NULL\
            CALL std_getWareHouseReplenishDays(l_hdr.brcode, l_pickingScheduleBranches[i]) RETURNING l_replenishDays\
            IF l_replenishDays.getLength() = 0 THEN\
                CALL setupWhseRepldays(l_hdr.brcode, l_pickingScheduleBranches[i]) RETURNING l_replenishDays\
            END IF\
            FOR j = 1 TO l_replenishDays.getLength()\
                LET l_supplierProductGroupRepDays[1].srd_mon = l_replenishDays[j].mon\
                LET l_supplierProductGroupRepDays[1].srd_tue = l_replenishDays[j].tue\
                LET l_supplierProductGroupRepDays[1].srd_wed = l_replenishDays[j].wed\
                LET l_supplierProductGroupRepDays[1].srd_thu = l_replenishDays[j].thu\
                LET l_supplierProductGroupRepDays[1].srd_fri = l_replenishDays[j].fri\
                LET l_supplierProductGroupRepDays[1].srd_sat = l_replenishDays[j].sat\
                LET l_supplierProductGroupRepDays[1].srd_sun = l_replenishDays[j].sun\
                LET l_supplierProductGroupRepDays[1].srd_repno = l_replenishDays[j].salesPerson\
                LET l_supplierProductGroupRepDays[1].srd_status = "Y"\
                LET l_supplierProductGroupRepDays[1].srd_suppno = l_pickingScheduleBranches[i]\
                LET l_supplierProductGroupRepDays[1].srd_balance = "N"\
                CALL lib_getSupplierName(l_supplierProductGroupRepDays[1].srd_suppno, lib_convertState2ToState1(l_brstate))\
                    RETURNING l_supplierProductGroupRepDays[1].spname\
                LET l_supplierProductGroupRepDays[1].spname = l_supplierProductGroupRepDays[1].spname CLIPPED, " - ", getDeliveryGroupCode(l_replenishDays[j].deliveryGroupId) CLIPPED\
                LET l_supplierProductGroupRepDays[1].delivery_group = l_replenishDays[j].deliveryGroupId\
                LET l_record_count = l_record_count + 1\
                INSERT INTO tmp_repl VALUES (l_supplierProductGroupRepDays[1].*)\
            END FOR\
            LET l_record_count = l_record_count + 1\
            LET l_whse_found = TRUE\
        END FOR\
\
        INITIALIZE l_supplierProductGroupRepDays TO NULL\
\
        -- Build all data from repl_days for branch into temp table\
        LET l_query = "SELECT srd_suppno, '', srd_repno, srd_mon,",\
                            " srd_tue, srd_wed, srd_thu, srd_fri,",\
                            " srd_sat, srd_sun, srd_status, srd_balance",\
                      "  FROM repl_days",\
                      " WHERE srd_brcode = '", l_hdr.brcode, "'"\
\
        PREPARE repldprep FROM l_query\
        DECLARE repldcurs CURSOR FOR repldprep\
\
        FOREACH repldcurs INTO l_supplierProductGroupRepDays[1].*\
            IF l_supplierProductGroupRepDays[1].srd_balance = "Y" THEN\
                LET l_supplierProductGroupRepDays[1].spname = "Balance of Suppliers"\
                LET l_bal_found = TRUE\
            ELSE\
                CALL lib_getSupplierName(l_supplierProductGroupRepDays[1].srd_suppno, lib_convertState2ToState1(l_brstate))\
                    RETURNING l_supplierProductGroupRepDays[1].spname\
            END IF\
\
            LET l_record_count = l_record_count + 1\
\
            INSERT INTO tmp_repl VALUES (l_supplierProductGroupRepDays[1].*)\
\
        END FOREACH\
\
        LET l_record_count = l_record_count - 1\
\
        -- If no records found then create the catch-all record\
        IF l_record_count = 0 OR        \{* No records found *\}\
           NOT l_bal_found THEN         \{* No balance found *\}\
            LET l_supplierProductGroupRepDays[1].srd_suppno = NULL\
            LET l_supplierProductGroupRepDays[1].spname     = "Balance of Suppliers"\
            LET l_supplierProductGroupRepDays[1].srd_repno  = NULL\
            LET l_supplierProductGroupRepDays[1].srd_mon    = "N"\
            LET l_supplierProductGroupRepDays[1].srd_tue    = "N"\
            LET l_supplierProductGroupRepDays[1].srd_wed    = "N"\
            LET l_supplierProductGroupRepDays[1].srd_thu    = "N"\
            LET l_supplierProductGroupRepDays[1].srd_fri    = "N"\
            LET l_supplierProductGroupRepDays[1].srd_sat    = "N"\
            LET l_supplierProductGroupRepDays[1].srd_sun    = "N"\
            LET l_supplierProductGroupRepDays[1].srd_status = "N"\
            LET l_supplierProductGroupRepDays[1].srd_balance= "Y"\
            INSERT INTO tmp_repl VALUES (l_supplierProductGroupRepDays[1].*)\
\
        END IF\
\
        DISPLAY BY NAME l_hdr.*                  \
\
        WHILE(TRUE)\
\
            -- Retrieve/Sort data from temp table into array.\
            LET l_query = "SELECT *",\
                          "  FROM tmp_repl",\
                          " WHERE (srd_mon = 'Y' OR srd_tue = 'Y' OR srd_wed = 'Y' OR srd_thu = 'Y' OR srd_fri = 'Y' OR srd_sat = 'Y' OR srd_sun = 'Y')"\
\
            IF LENGTH(l_hdr.sprepcode) > 0 THEN\
                LET l_query = l_query CLIPPED,\
                        "   AND srd_repno = '", l_hdr.sprepcode, "'",\
                        "    OR srd_balance = 'Y'"    \{* Always want balance *\}\
\
                IF NOT l_whse_found THEN\
                    -- If a WHSE record was not found then always\
                    -- include the Warehouse record even when only\
                    -- viewing records for a particular salesperson.\
                    LET l_query = l_query CLIPPED,\
                           " OR srd_repno IS NULL"\
                END IF\
            END IF\
\
            IF l_toggle THEN\
                LET l_query = l_query CLIPPED,\
                            " ORDER BY srd_balance ASC, srd_suppno, srd_repno"\
            ELSE\
                LET l_query = l_query CLIPPED,\
                            " ORDER BY srd_balance ASC, srd_repno, srd_suppno"\
            END IF\
\
            PREPARE repl2prep FROM l_query\
            DECLARE repl2curs CURSOR FOR repl2prep\
\
            LET l_record_count = 1\
            INITIALIZE l_supplierProductGroupRepDays TO NULL\
            FOREACH repl2curs INTO l_supplierProductGroupRepDays[l_record_count].*\
                LET l_record_count = l_record_count + 1\
            END FOREACH\
\
            CALL l_supplierProductGroupRepDays.deleteElement(l_record_count)\
\
            LET l_record_count = l_record_count - 1\
\
            IF l_supplierProductGroupRepDays[l_record_count].srd_balance = "N" THEN\
                -- Last record was not the Balance, retrieve it.\
                SELECT *\
                  INTO l_supplierProductGroupRepDays[l_record_count].*\
                  FROM tmp_repl\
                 WHERE srd_balance = "Y"\
            END IF\
\
            -- Display it\
\
            LET l_insert = FALSE\
            LET l_cont = FALSE\
            LET l_print = FALSE\
            INPUT ARRAY l_supplierProductGroupRepDays WITHOUT DEFAULTS FROM scr_rd.* \
            ATTRIBUTES(INSERT ROW=FALSE, APPEND ROW=TRUE, DELETE ROW=TRUE, NORMAL)\
\
                BEFORE ROW\
                    LET l_arr = arr_curr()\
                    LET l_scr = scr_line()\
                    LET l_previousSupplier.suppno = l_supplierProductGroupRepDays[l_arr].srd_suppno\
                    LET l_previousSupplier.suppname = l_supplierProductGroupRepDays[l_arr].spname\
                    IF NOT canUpdateReplenishSupplier(l_supplierProductGroupRepDays[l_arr].*) THEN\
                        NEXT FIELD srd_repno\
                    END IF\
\
                AFTER ROW\
                    IF check_del("") THEN\
                        LET l_ok = FALSE\
                        EXIT INPUT\
                    END IF\
                    IF LENGTH(l_supplierProductGroupRepDays[l_arr].spname) > 0 THEN\
                        IF LENGTH(l_supplierProductGroupRepDays[l_arr].srd_repno) = 0 THEN\
                            ERROR " Salesperson Number must be set! "\
                            NEXT FIELD srd_repno\
                        END IF\
\
                        IF l_supplierProductGroupRepDays[l_arr].srd_balance = "Y" THEN\
                            LET l_allowedReplDays = l_defaultReplDays\
                        ELSE\
                            LET l_allowedReplDays = l_supplierReplDays\
                        END IF\
\
                        CALL validateReplenishDays(l_supplierProductGroupRepDays[l_arr].*, "Y", l_allowedReplDays) \
                            RETURNING l_ok, l_message\
                        IF NOT l_ok THEN\
                            ERROR l_message\
                            NEXT FIELD srd_mon\
                        END IF\
                    END IF\
                    IF l_previousSupplier.suppno != l_supplierProductGroupRepDays[l_arr].srd_suppno THEN\
                        DELETE FROM tmp_repl\
                         WHERE srd_suppno = l_previousSupplier.suppno\
                    END IF\
\
                BEFORE INSERT\
                    LET l_insert = TRUE\
\
                BEFORE DELETE\
                    CALL canDeleteReplenishDaysRecord(l_supplierProductGroupRepDays[l_arr].*)\
                        RETURNING l_ok, l_message\
                    IF NOT l_ok THEN\
                        ERROR l_message\
                        CANCEL DELETE\
                        NEXT FIELD srd_suppno\
                    END IF\
                    DELETE FROM tmp_repl\
                     WHERE srd_suppno = l_supplierProductGroupRepDays[l_arr].srd_suppno\
                     \
                AFTER DELETE\
                    IF l_arr > 1 THEN\
                        CALL lib_move_to_row(l_arr-1)\
                    END IF\
\
                BEFORE FIELD srd_suppno\
                    IF NOT canUpdateReplenishSupplier(l_supplierProductGroupRepDays[l_arr].*) THEN\
                        NEXT FIELD srd_repno\
                    END IF\
\
                AFTER FIELD srd_suppno\
\
                    IF NOT compare(l_supplierProductGroupRepDays[l_arr].srd_suppno, l_previousSupplier.suppno) OR \
                       l_previousSupplier.suppno IS NULL THEN\
                       \
                        CALL validateReplenishSupplier(l_hdr.brcode, l_supplierProductGroupRepDays, l_arr)\
                            RETURNING l_ok, l_message, l_supplierProductGroupRepDays[l_arr].spname\
                            \
                        IF NOT l_ok THEN\
                        \
                            LET l_supplierProductGroupRepDays[l_arr].srd_suppno = l_previousSupplier.suppno\
                            LET l_supplierProductGroupRepDays[l_arr].spname = l_previousSupplier.suppname\
\
                            DISPLAY l_supplierProductGroupRepDays[l_arr].srd_suppno TO scr_rd[l_scr].srd_suppno \
                            DISPLAY l_supplierProductGroupRepDays[l_arr].spname TO scr_rd[l_scr].spname\
\
                            ERROR l_message\
                            NEXT FIELD srd_suppno\
                        ELSE\
\
                            IF isNewReplenishDaysRecord(l_supplierProductGroupRepDays[l_arr].*) THEN\
                                -- Adding new line : Default values when new supplier entered\
                                CALL initNewReplenishDaysRecord(l_supplierProductGroupRepDays[l_arr].*, l_hdr.sprepcode)\
                                    RETURNING l_supplierProductGroupRepDays[l_arr].*\
                                DISPLAY l_supplierProductGroupRepDays[l_arr].* TO scr_rd[l_scr].*                  \
                            END IF\
\
                            DISPLAY l_supplierProductGroupRepDays[l_arr].spname TO scr_rd[l_scr].spname                        \
                            NEXT FIELD srd_repno\
                        END IF\
                    END IF\
\
                BEFORE FIELD srd_repno\
                    LET l_old_repno = l_supplierProductGroupRepDays[l_arr].srd_repno\
\
                AFTER FIELD srd_repno\
                    IF NOT compare(l_old_repno, l_supplierProductGroupRepDays[l_arr].srd_repno) THEN\
                        IF l_supplierProductGroupRepDays[l_arr].delivery_group IS NOT NULL THEN\
                            IF l_supplierProductGroupRepDays[l_arr].delivery_group <> std_getStandardProductDeliveryGroupId() THEN\
                                ERROR "Salesperson of standard group can only be updated"\
                                LET l_supplierProductGroupRepDays[l_arr].srd_repno = l_old_repno\
                                NEXT FIELD srd_repno\
                            END IF\
                        END IF\
                    END IF\
                    IF NOT std_isSalespersonEnabled(l_hdr.brcode, l_supplierProductGroupRepDays[l_arr].srd_repno) THEN\
                        IF l_supplierProductGroupRepDays[l_arr].delivery_group IS NOT NULL THEN\
                            IF l_supplierProductGroupRepDays[l_arr].delivery_group = std_getStandardProductDeliveryGroupId() THEN\
                                ERROR "Invalid Salesperson Number! "\
                                NEXT FIELD srd_repno\
                            END IF\
                        ELSE\
                            ERROR "Invalid Salesperson Number! "\
                            NEXT FIELD srd_repno\
                        END IF \
                    END IF\
\
                BEFORE FIELD srd_mon\
                    IF l_supplierProductGroupRepDays[l_arr].srd_status = "Y" THEN\
                        NEXT FIELD srd_status\
                    END IF\
\
                BEFORE FIELD srd_tue\
                    IF l_supplierProductGroupRepDays[l_arr].srd_status = "Y" THEN\
                        NEXT FIELD srd_status\
                    END IF\
\
                BEFORE FIELD srd_wed\
                    IF l_supplierProductGroupRepDays[l_arr].srd_status = "Y" THEN\
                        NEXT FIELD srd_status\
                    END IF\
\
                BEFORE FIELD srd_thu\
                    IF l_supplierProductGroupRepDays[l_arr].srd_status = "Y" THEN\
                        NEXT FIELD srd_status\
                    END IF\
\
                BEFORE FIELD srd_fri\
                    IF l_supplierProductGroupRepDays[l_arr].srd_status = "Y" THEN\
                        NEXT FIELD srd_status\
                    END IF\
\
                BEFORE FIELD srd_sat\
                    IF l_supplierProductGroupRepDays[l_arr].srd_status = "Y" THEN\
                        NEXT FIELD srd_status\
                    END IF\
\
                BEFORE FIELD srd_sun\
                    IF l_supplierProductGroupRepDays[l_arr].srd_status = "Y" THEN\
                        NEXT FIELD srd_status\
                    END IF\
\
                 ON ACTION supplier_search INFIELD srd_suppno \{F1=Select Supplier\}\
                    IF l_supplierProductGroupRepDays[l_arr].srd_balance != "Y" OR\
                       l_supplierProductGroupRepDays[l_arr].srd_balance IS NULL THEN\
                       \
                        IF supp_win("") THEN\
                        \
                            LET l_supplierProductGroupRepDays[l_arr].srd_suppno = p_ssel.spsuppno\
\
                            CALL validateReplenishSupplier(l_hdr.brcode, l_supplierProductGroupRepDays, l_arr)\
                                RETURNING l_ok, l_message, l_supplierProductGroupRepDays[l_arr].spname\
                            IF NOT l_ok THEN\
                    \
                                LET l_supplierProductGroupRepDays[l_arr].srd_suppno = l_previousSupplier.suppno\
                                LET l_supplierProductGroupRepDays[l_arr].spname = l_previousSupplier.suppname\
\
                                DISPLAY l_supplierProductGroupRepDays[l_arr].srd_suppno TO scr_rd[l_scr].srd_suppno \
                                DISPLAY l_supplierProductGroupRepDays[l_arr].spname TO scr_rd[l_scr].spname\
                        \
                                ERROR l_message\
                                NEXT FIELD srd_suppno\
                        \
                            END IF\
                            \
                            DISPLAY l_supplierProductGroupRepDays[l_arr].srd_suppno, l_supplierProductGroupRepDays[l_arr].spname\
                                 TO scr_rd[l_scr].srd_suppno,  scr_rd[l_scr].spname\
                                                     \
                        END IF\
                        \
                    END IF\
\
                    ON ACTION salesperson_search INFIELD srd_repno \{F1=Select Salesperson\}\
                        CALL std_selectSalesperson(l_hdr.brcode, NULL, NULL)\
                            RETURNING l_supplierProductGroupRepDays[l_arr].srd_repno, l_notused\
                        IF LENGTH(l_supplierProductGroupRepDays[l_arr].srd_repno) = 0 THEN\
                            ERROR " Invalid Salesperson Number! "\
                            LET l_supplierProductGroupRepDays[l_arr].srd_repno = l_old_repno\
                            DISPLAY l_supplierProductGroupRepDays[l_arr].srd_repno\
                                 TO scr_rd[l_scr].srd_repno                  \
                            NEXT FIELD srd_repno\
                        END IF\
                        DISPLAY l_supplierProductGroupRepDays[l_arr].srd_repno\
                             TO scr_rd[l_scr].srd_repno                  \
\
                ON ACTION print \{F8=* Print *\}\
                    IF LENGTH(l_supplierProductGroupRepDays[l_arr].spname) > 0 THEN\
                        IF LENGTH(l_supplierProductGroupRepDays[l_arr].srd_repno) = 0 THEN\
                            ERROR " Salesperson Number must be set! "\
                            NEXT FIELD srd_repno\
                        END IF\
\
                        IF l_supplierProductGroupRepDays[l_arr].srd_balance = "Y" THEN\
                            LET l_allowedReplDays = l_defaultReplDays\
                        ELSE\
                            LET l_allowedReplDays = l_supplierReplDays\
                        END IF\
\
                        CALL validateReplenishDays(l_supplierProductGroupRepDays[l_arr].*, "Y", l_allowedReplDays) \
                            RETURNING l_ok, l_message\
                        IF NOT l_ok THEN\
                            ERROR l_message\
                            NEXT FIELD srd_mon\
                        END IF\
                    END IF\
                    IF l_previousSupplier.suppno != l_supplierProductGroupRepDays[l_arr].srd_suppno THEN\
                        DELETE FROM tmp_repl\
                         WHERE srd_suppno = l_previousSupplier.suppno\
                    END IF\
                    LET l_cont = TRUE\
                    LET l_print = TRUE\
                    LET l_record_count = arr_count()\
                    EXIT INPUT\
\
                ON ACTION show_schedule \{F10=Whs Schedules, * Show schedule *\}\
                    CALL show_replen_schedule(l_hdr.brcode)\
\
                AFTER INPUT\
                    IF check_del("") THEN\
                        LET l_ok = FALSE\
                        EXIT INPUT\
                    END IF\
                    IF l_supplierProductGroupRepDays[l_arr].srd_suppno IS NULL AND\
                       l_previousSupplier.suppno IS NOT NULL THEN\
                        -- Cannot remove a supplier by blanking out supplier code\
                        ERROR " Use F2 to Delete supplier! "\
                        LET l_supplierProductGroupRepDays[l_arr].srd_suppno = l_previousSupplier.suppno\
                        NEXT FIELD srd_suppno\
                    END IF\
                    IF l_previousSupplier.suppno != l_supplierProductGroupRepDays[l_arr].srd_suppno THEN\
                        DELETE FROM tmp_repl\
                         WHERE srd_suppno = l_previousSupplier.suppno\
                    END IF\
                    FOR l_idx = 1 TO arr_count()\
                        IF l_supplierProductGroupRepDays[l_idx].srd_balance = "Y" THEN\
                            IF LENGTH(l_supplierProductGroupRepDays[l_idx].srd_repno) = 0 THEN\
                                ERROR " Salesperson must be entered for",\
                                      " Balance of Suppliers record! "\
                                NEXT FIELD srd_repno\
                            END IF\
                        END IF\
                    END FOR\
                    LET l_record_count = arr_count()\
\
            END INPUT\
\
            IF NOT l_ok THEN\
                EXIT WHILE\
            END IF\
\
            -- Maintain the temp table from the input array\
            FOR l_idx = 1 TO l_record_count\
                IF LENGTH(l_supplierProductGroupRepDays[l_idx].spname) > 0 THEN\
                    IF LENGTH(l_supplierProductGroupRepDays[l_idx].srd_balance) = 0 THEN\
                        LET l_supplierProductGroupRepDays[l_idx].srd_balance = "N"\
                    END IF\
                    IF l_supplierProductGroupRepDays[l_idx].srd_balance = "N" THEN\
                        IF l_supplierProductGroupRepDays[l_idx].delivery_group IS NOT NULL THEN\
                            UPDATE tmp_repl\
                               SET srd_repno  = l_supplierProductGroupRepDays[l_idx].srd_repno,\
                                   srd_mon    = l_supplierProductGroupRepDays[l_idx].srd_mon,\
                                   srd_tue    = l_supplierProductGroupRepDays[l_idx].srd_tue,\
                                   srd_wed    = l_supplierProductGroupRepDays[l_idx].srd_wed,\
                                   srd_thu    = l_supplierProductGroupRepDays[l_idx].srd_thu,\
                                   srd_fri    = l_supplierProductGroupRepDays[l_idx].srd_fri,\
                                   srd_sat    = l_supplierProductGroupRepDays[l_idx].srd_sat,\
                                   srd_sun    = l_supplierProductGroupRepDays[l_idx].srd_sun,\
                                   srd_status = l_supplierProductGroupRepDays[l_idx].srd_status\
                             WHERE srd_suppno = l_supplierProductGroupRepDays[l_idx].srd_suppno\
                               AND delivery_group = l_supplierProductGroupRepDays[l_idx].delivery_group\
                        ELSE\
                            UPDATE tmp_repl\
                               SET srd_repno  = l_supplierProductGroupRepDays[l_idx].srd_repno,\
                                   srd_mon    = l_supplierProductGroupRepDays[l_idx].srd_mon,\
                                   srd_tue    = l_supplierProductGroupRepDays[l_idx].srd_tue,\
                                   srd_wed    = l_supplierProductGroupRepDays[l_idx].srd_wed,\
                                   srd_thu    = l_supplierProductGroupRepDays[l_idx].srd_thu,\
                                   srd_fri    = l_supplierProductGroupRepDays[l_idx].srd_fri,\
                                   srd_sat    = l_supplierProductGroupRepDays[l_idx].srd_sat,\
                                   srd_sun    = l_supplierProductGroupRepDays[l_idx].srd_sun,\
                                   srd_status = l_supplierProductGroupRepDays[l_idx].srd_status\
                             WHERE srd_suppno = l_supplierProductGroupRepDays[l_idx].srd_suppno\
                        END IF\
                        IF status != 0 OR\
                           SQLCA.SQLERRD[3] = 0 THEN\
                            INSERT INTO tmp_repl VALUES (l_supplierProductGroupRepDays[l_idx].*)\
                        END IF\
                    ELSE\
                        UPDATE tmp_repl\
                           SET srd_repno  = l_supplierProductGroupRepDays[l_idx].srd_repno,\
                               srd_mon    = l_supplierProductGroupRepDays[l_idx].srd_mon,\
                               srd_tue    = l_supplierProductGroupRepDays[l_idx].srd_tue,\
                               srd_wed    = l_supplierProductGroupRepDays[l_idx].srd_wed,\
                               srd_thu    = l_supplierProductGroupRepDays[l_idx].srd_thu,\
                               srd_fri    = l_supplierProductGroupRepDays[l_idx].srd_fri,\
                               srd_sat    = l_supplierProductGroupRepDays[l_idx].srd_sat,\
                               srd_sun    = l_supplierProductGroupRepDays[l_idx].srd_sun,\
                               srd_status = l_supplierProductGroupRepDays[l_idx].srd_status\
                         WHERE srd_balance = "Y"\
                    END IF\
                END IF\
            END FOR\
\
            IF l_print THEN\
                IF l_record_count <= 0 THEN\
                    ERROR " No records to print! "\
                ELSE\
                    CALL print_repl_days(l_query, l_hdr.brcode)\
                END IF\
            END IF\
\
            IF l_cont THEN\
                CONTINUE WHILE\
            END IF\
\
            -- Clear existing records\
            DELETE FROM repl_days\
                  WHERE srd_brcode = l_hdr.brcode\
\
            -- Now insert records from temp\
            LET l_rd.srd_brcode = l_hdr.brcode\
\
            DECLARE replupdcur CURSOR FOR\
             SELECT *\
               FROM tmp_repl\
            FOREACH replupdcur INTO l_supplierProductGroupRepDays[1].*\
                LET l_rd.srd_balance   = l_supplierProductGroupRepDays[1].srd_balance\
                LET l_rd.srd_suppno    = l_supplierProductGroupRepDays[1].srd_suppno\
                LET l_rd.srd_lead_days = NULL\
                LET l_rd.srd_repno     = l_supplierProductGroupRepDays[1].srd_repno\
                LET l_rd.srd_mon       = l_supplierProductGroupRepDays[1].srd_mon\
                LET l_rd.srd_tue       = l_supplierProductGroupRepDays[1].srd_tue\
                LET l_rd.srd_wed       = l_supplierProductGroupRepDays[1].srd_wed\
                LET l_rd.srd_thu       = l_supplierProductGroupRepDays[1].srd_thu\
                LET l_rd.srd_fri       = l_supplierProductGroupRepDays[1].srd_fri\
                LET l_rd.srd_sat       = l_supplierProductGroupRepDays[1].srd_sat\
                LET l_rd.srd_sun       = l_supplierProductGroupRepDays[1].srd_sun\
                LET l_rd.srd_status    = l_supplierProductGroupRepDays[1].srd_status\
                LET l_rd.srd_repno     = l_supplierProductGroupRepDays[1].srd_repno\
                IF l_supplierProductGroupRepDays[1].delivery_group IS NOT NULL THEN\
                    IF std_getStandardProductDeliveryGroupId() = l_supplierProductGroupRepDays[1].delivery_group THEN    \{ Update only standard delivery group \}\
                        UPDATE whse_delivery_zone_branch\
                           SET wdzb_salesperson_code = l_supplierProductGroupRepDays[1].srd_repno\
                         WHERE wdzb_id = (SELECT UNIQUE wdzb_id\
                                            FROM whse_delivery_zone, whse_delivery_zone_branch, whse_delivery_link, whse_delivery_link_schedule\
                                           WHERE wdz_id                = wdzb_delivery_zone_id\
                                             AND wdl_zone_id           = wdz_id\
                                             AND wdl_id                = wdls_link_id\
                                             AND wdzb_branch_code      = l_hdr.brcode\
                                             AND wdz_whse_code         = l_rd.srd_suppno\
                                             AND wdl_group_id          = l_supplierProductGroupRepDays[1].delivery_group\
                                             AND wdls_branch_replenish = "Y")\
                    END IF\
                ELSE \
                    IF l_rd.srd_status = "N" THEN\
                        INSERT INTO repl_days VALUES (l_rd.*)\
                    END IF\
                END IF \
            END FOREACH\
\
            EXIT WHILE\
        END WHILE\
\
        -- Return to the header input.\
        DISPLAY "", "", "", "" -- , "", ""\
             TO brcode, brname, sprepcode, sprepname --,  nr_day, nr_dmy\
\
        FOR l_arr = 1 TO l_record_count\
            CLEAR scr_rd[l_arr].*\
        END FOR\
\
    END WHILE\
\
    CLOSE WINDOW repldaywin\
\
END FUNCTION\
\
\{******************************************************************************\}\
\
FUNCTION print_repl_days(l_query, l_brcode)\
\
 DEFINE l_query                             CHAR(300),\
        l_brcode                       LIKE branch.brcode,\
        spl RECORD\
            spl_no                          CHAR(7),\
            spl_filename                    CHAR(25),\
            spl_desc                        CHAR(30),\
            spl_type                        CHAR(2),\
            spl_hold                        CHAR(1)\
        END RECORD,\
        l_spl_ok                            SMALLINT,\
        l_rd_rep RECORD\
            srd_suppno                 LIKE repl_days.srd_suppno,\
            spname                     LIKE supplier.spname,\
            srd_repno                  LIKE repl_days.srd_repno,\
            srd_mon                    LIKE repl_days.srd_mon,\
            srd_tue                    LIKE repl_days.srd_tue,\
            srd_wed                    LIKE repl_days.srd_wed,\
            srd_thu                    LIKE repl_days.srd_thu,\
            srd_fri                    LIKE repl_days.srd_fri,\
            srd_sat                    LIKE repl_days.srd_sat,\
            srd_sun                    LIKE repl_days.srd_sun,\
            srd_status                 LIKE repl_days.srd_status,\
            srd_balance                LIKE repl_days.srd_balance\
        END RECORD\
\
    LET spl.spl_type = "RE"\
    LET spl.spl_desc = "Replenish Days Report"\
    CALL start_spool(spl.*) RETURNING l_spl_ok, spl.*\
    IF NOT l_spl_ok THEN\
        MESSAGE " Report Aborted... "\
        RETURN\
    END IF\
    START REPORT rep_days_rep TO spl.spl_filename\
\
    -- Query string already created outside function,\
    -- so just prepare and declare\
\
    PREPARE rdrepprep FROM l_query\
    DECLARE rdrepcur CURSOR FOR rdrepprep\
\
    INITIALIZE l_rd_rep TO NULL\
    FOREACH rdrepcur INTO l_rd_rep.*\
\
        OUTPUT TO REPORT rep_days_rep(l_brcode, l_rd_rep.*)\
        INITIALIZE l_rd_rep TO NULL\
\
    END FOREACH\
\
    FINISH REPORT rep_days_rep\
    CALL finish_spool(spl.*)\
\
END FUNCTION\
\
\{******************************************************************************\}\
\
REPORT rep_days_rep(l_rep)\
\
 DEFINE l_rep RECORD\
            brcode                     LIKE branch.brcode,\
            srd_suppno                 LIKE repl_days.srd_suppno,\
            spname                     LIKE supplier.spname,\
            srd_repno                  LIKE repl_days.srd_repno,\
            srd_mon                    LIKE repl_days.srd_mon,\
            srd_tue                    LIKE repl_days.srd_tue,\
            srd_wed                    LIKE repl_days.srd_wed,\
            srd_thu                    LIKE repl_days.srd_thu,\
            srd_fri                    LIKE repl_days.srd_fri,\
            srd_sat                    LIKE repl_days.srd_sat,\
            srd_sun                    LIKE repl_days.srd_sun,\
            srd_status                 LIKE repl_days.srd_status,\
            srd_balance                LIKE repl_days.srd_balance\
        END RECORD,\
        l_repname                      LIKE salesperson.sprepname\
\
  OUTPUT\
    PAGE LENGTH 60\
    TOP OF PAGE "^L"\
\
  FORMAT\
    PAGE HEADER\
        PRINT COLUMN  1, "REPLENISH DAYS REPORT",\
              COLUMN 71, TODAY USING "PRINTED ON dd/mm/yyyy"," AT ", TIME,\
                         " BY ", p_usrid,\
              COLUMN 118, PAGENO USING "PAGE : <<<<"\
        PRINT COLUMN   1, "Branch: ", l_rep.brcode, " ", lib_get_branchName(l_rep.brcode)\
        PRINT COLUMN 103, "--Weekdays---",\
              COLUMN 118, "Admin"\
        PRINT COLUMN   3, "Supplier",\
              COLUMN  55, "Salesperson",\
              COLUMN 103, "M T W T F S S",\
              COLUMN 118, "Assigned"\
        SKIP 1 LINES\
\
    ON EVERY ROW\
        SELECT sprepname\
          INTO l_repname\
          FROM salesperson\
         WHERE spbrcode = l_rep.brcode\
           AND sprepcode = l_rep.srd_repno\
        IF status != 0 THEN\
            LET l_repname = "* Unknown *"\
        END IF\
        PRINT COLUMN   1, l_rep.srd_suppno USING "##########",\
              COLUMN  13, l_rep.spname CLIPPED,\
              COLUMN  55, l_rep.srd_repno CLIPPED,\
              COLUMN  59, l_repname CLIPPED,\
              COLUMN 103, l_rep.srd_mon,\
              COLUMN 105, l_rep.srd_tue,\
              COLUMN 107, l_rep.srd_wed,\
              COLUMN 109, l_rep.srd_thu,\
              COLUMN 111, l_rep.srd_fri,\
              COLUMN 113, l_rep.srd_sat,\
              COLUMN 115, l_rep.srd_sun,\
              COLUMN 120, l_rep.srd_status\
\
    ON LAST ROW\
        SKIP 2 LINES\
        PRINT COLUMN 50, "*** End Of Report ***"\
\
END REPORT\
\
\{******************************************************************************\}\
\
\
\
\{******************************************************************************\}\
\
FUNCTION select_state()\
\
 DEFINE l_state                    LIKE supplier.spstate\
\
    LET p_genwin.search_title  = " Select State "\
    LET p_genwin.table         = "lukup"\
    LET p_genwin.column1       = "lucode"\
    LET p_genwin.column2       = "ludesc"\
    LET p_genwin.column1_title = "Statecode"\
    LET p_genwin.column2_title = "State Name"\
    LET p_genwin.where         = " lutabid = 'S1'",\
                                 " AND lucode IS NOT NULL"\
    LET p_genwin.order_by      = "lucode"\
    LET p_genwin.descending    = FALSE\
\
    IF gen_win() THEN\
        LET l_state = p_gensel.code\
    ELSE\
        LET l_state = NULL\
    END IF\
\
    OPTIONS FORM LINE 1\
    RETURN l_state\
\
END FUNCTION\
\
\{******************************************************************************\}\
\
FUNCTION select_branch_list()\
\
 DEFINE l_branch                        CHAR(78),\
        l_count                         SMALLINT\
\
    LET p_genwin.search_title  = " Select Branch(s) "\
    LET p_genwin.table         = "branch"\
    LET p_genwin.column1       = "brcode"\
    LET p_genwin.column2       = "brname"\
    LET p_genwin.column1_title = "Code"\
    LET p_genwin.column2_title = "Branch Name"\
    LET p_genwin.where         = " brposlive = 'Y'"\
    LET p_genwin.order_by      = "brcode"\
    LET p_genwin.descending    = FALSE\
\
    IF gen_multi_sel_win("BR") THEN\
        CALL gen_multi_selected("D", "BR") RETURNING l_branch, l_count\
        IF l_count = 0 THEN\
            LET l_branch = NULL\
        END IF\
    ELSE\
        LET l_branch = NULL\
    END IF\
\
    OPTIONS FORM LINE 1\
    RETURN l_branch\
\
END FUNCTION\
\
\{******************************************************************************\}\
\{* Admin Allocated Stock                                                      *\}\
\{******************************************************************************\}\
\
FUNCTION admin_alloc_stock()\
\
 DEFINE l_hdr RECORD\
            rd_prodno              LIKE replenish_data.rd_prodno,\
            pmdesc                 LIKE product.pmdesc,\
            rmq                    LIKE product.pmmultqty,\
            rd_suppstate           LIKE replenish_data.rd_suppstate,\
            statedesc              LIKE lukup.ludesc,\
            regionman                   CHAR(40),\
            branch_list                 CHAR(40),\
            scheme		           LIKE bstock.bsscheme\
        END RECORD,\
        l_include_showrooms             BOOLEAN,  \
        l_rdarr ARRAY[500] OF RECORD\
            brcode                 LIKE branch.brcode,\
            brname                 LIKE branch.brname,\
            rd_repqty              LIKE replenish_data.rd_repqty,\
            rd_effdmy              LIKE replenish_data.rd_effdmy,\
            rd_serialno            LIKE replenish_data.rd_serialno\
        END RECORD,\
        l_rdrec RECORD\
            brcode                 LIKE branch.brcode,\
            brname                 LIKE branch.brname,\
            rd_repqty              LIKE replenish_data.rd_repqty,\
            rd_effdmy              LIKE replenish_data.rd_effdmy,\
            rd_serialno            LIKE replenish_data.rd_serialno\
        END RECORD,\
        c_arr_max                       SMALLINT,\
        c_scr_max                       SMALLINT,\
        l_arr_cnt, l_cnt                SMALLINT,\
        l_arr, l_scr, l_ok              SMALLINT,\
        l_rd RECORD                LIKE replenish_data.*,\
        l_notused                       SMALLINT,\
        l_where                         CHAR(300),\
        l_query                         STRING,\
        l_regionman                     CHAR(40),\
        l_branch_list                   CHAR(40),\
        l_old_brcode               LIKE branch.brcode,\
        l_brcode                   LIKE replenish_data.rd_brcode,\
        l_qty                      LIKE replenish_data.rd_repqty,\
        l_serialno                      INTEGER,\
        l_cont, l_idx                   SMALLINT,\
        l_qty_int                       INTEGER,\
        l_scheme_recalc                 SMALLINT,\
        l_rmq                      LIKE product.pmmultqty,\
        l_2ws                      LIKE bstock.bssys_avg2ws,\
        l_ocf                      LIKE bstock.bssys_ocf,\
        l_branch_sel                    SMALLINT,\
        l_msg                           CHAR(50),\
        l_butText                       STRING,\
        l_butQueryText                  STRING,\
        l_butCount                      INTEGER,\
        l_schemeComboxBox               ui.ComboBox,\
        l_forecast                      DECIMAL(11,4),\
        l_change_sch                    SMALLINT,\
        l_prodno		           LIKE replenish_data.rd_prodno\
\
    LET c_arr_max = 500             \{* Max size of l_rdarr Array *\}\
    LET c_scr_max = 11              \{* Size of the screen array *\}\
\
    LET l_butCount = 0\
    LET l_butQueryText = ""\
\
    OPEN FORM aas_form FROM "forms/por1100g2"\
\
    DISPLAY FORM aas_form \
    CALL lib_set_form_toolbar("Array")\
    CALL std_buildSchemeComboBox("formonly.scheme") RETURNING l_schemeComboxBox\
    CALL l_schemeComboxBox.removeItem("M")\
    CALL l_schemeComboxBox.removeItem("F")\
    CALL l_schemeComboxBox.removeItem("O")\
    CALL l_schemeComboxBox.removeItem("N")\
    \
    LET l_cont       = FALSE\
    LET l_branch_sel = TRUE\
    LET l_include_showrooms = FALSE\
    LET l_change_sch = FALSE\
    LET l_prodno = NULL\
    \
    WHILE(TRUE)\
        IF NOT l_cont THEN\
            INITIALIZE l_hdr, l_rdarr TO NULL\
        END IF\
\
        LET l_ok = TRUE\
\
        IF l_branch_sel THEN        -- START of Branch Selection Criterion\
            INPUT BY NAME l_hdr.rd_suppstate, l_include_showrooms WITHOUT DEFAULTS                  \
\
                BEFORE INPUT\
                    DISPLAY "ALL" TO but_label\
                    \
\
                AFTER FIELD rd_suppstate\
                    IF LENGTH(l_hdr.rd_suppstate) > 0 THEN\
                        LET l_hdr.statedesc = lib_get_ludesc("S1", l_hdr.rd_suppstate)\
\
                        DISPLAY BY NAME l_hdr.rd_suppstate, l_hdr.statedesc \
                        \
                        IF LENGTH(l_hdr.statedesc) = 0 THEN\
                            ERROR " Invalid State Code! "\
                            NEXT FIELD rd_suppstate\
                        END IF\
                    END IF\
\
                ON ACTION state_search INFIELD rd_suppstate \{F1=Search State\}\
                    CALL select_state() RETURNING l_hdr.rd_suppstate\
                    OPTIONS FORM LINE 3\
                    \
                    IF LENGTH(l_hdr.rd_suppstate) > 0 THEN\
                        LET l_hdr.statedesc = lib_get_ludesc("S1", l_hdr.rd_suppstate)\
                        \
                        IF LENGTH(l_hdr.statedesc) = 0 THEN\
                            ERROR " Invalid State Code! "\
                            NEXT FIELD rd_suppstate\
                        END IF\
                        \
                        DISPLAY BY NAME l_hdr.rd_suppstate, l_hdr.statedesc                  \
                    END IF\
\
                ON ACTION but_code \
                    CALL get_businessUnitQueryMulti() RETURNING l_butQueryText, l_butCount, l_butText\
                    DISPLAY l_butText TO but_label\
\
                AFTER INPUT\
                    IF check_del("") THEN\
                        LET l_ok = FALSE\
                        EXIT INPUT\
                    END IF\
            END INPUT\
\
            IF NOT l_ok THEN\
                EXIT WHILE\
            END IF\
\
            LET l_cont = FALSE\
            \
            CONSTRUCT BY NAME l_where ON regionman, rd_brcode                  \
                BEFORE FIELD regionman\
                    IF LENGTH(l_regionman) > 0 THEN\
                        DISPLAY l_regionman TO scr_hdr.regionman                  \
                        CALL std_getReportingRegions(l_regionman)\
                    END IF\
                    \
                AFTER FIELD regionman\
                    LET l_regionman = GET_FLDBUF(regionman)\
                    \
                    IF going_up() THEN\
                        LET l_cont = TRUE\
                        EXIT CONSTRUCT\
                    END IF\
                    \
                    IF LENGTH(l_regionman) > 0 THEN\
                        CALL std_getReportingRegions(l_regionman)\
                    END IF\
\
                BEFORE FIELD rd_brcode\
\
\
                ON ACTION region_search INFIELD regionman \{F1=Select Region\}\
                    CALL std_lookupRegionals("R", "Select Region", FALSE, "D", "") RETURNING l_regionman\
                    OPTIONS FORM LINE 3\
                    IF LENGTH(l_regionman) > 0 THEN\
                        DISPLAY l_regionman TO scr_hdr.regionman                  \
                        CALL std_getReportingRegions(l_regionman)\
                    END IF\
\
                ON ACTION branch_searchf1 INFIELD rd_brcode \{F1=Select Branch\}\
                    CALL select_branch_list() RETURNING l_branch_list\
                    OPTIONS FORM LINE 3\
                    \
                    IF LENGTH(l_branch_list) > 0 THEN\
                        DISPLAY l_branch_list TO scr_hdr.rd_brcode                  \
                    END IF\
\
                ON ACTION but_code\
                    CALL get_businessUnitQueryMulti()  RETURNING l_butQueryText, l_butCount, l_butText\
                    DISPLAY l_butText TO but_label\
\
                AFTER CONSTRUCT\
                    IF check_del("") THEN\
                        LET l_ok = FALSE\
                        EXIT CONSTRUCT\
                    END IF\
            END CONSTRUCT\
\
            IF LENGTH(l_where) > 0 THEN\
                CALL replace_word(l_where, "rd_brcode", "branch.brcode") RETURNING l_where\
            END IF\
\
            IF NOT l_ok THEN\
                EXIT WHILE\
            END IF\
\
            IF l_cont THEN\
                CONTINUE WHILE\
            END IF\
\
            LET l_change_sch = FALSE\
        END IF      -- END of Branch Selection Criterion\
        \
        LET l_branch_sel = FALSE\
\
        -- Now user selects product code\
        LET l_ok = TRUE\
        IF NOT l_change_sch THEN\
            LET l_hdr.rd_prodno = NULL\
            LET l_hdr.scheme = NULL\
        END IF\
        \
        INPUT BY NAME l_hdr.rd_prodno, l_hdr.scheme WITHOUT DEFAULTS                  \
            BEFORE INPUT\
                IF l_change_sch THEN\
                    LET l_hdr.scheme = p_bs.bsscheme \
                    NEXT FIELD scheme\
                ELSE\
		    \{ Default to Service scheme \}\
                    LET l_hdr.scheme = "S"\
                END IF\
  \
            BEFORE FIELD rd_prodno\
                IF l_change_sch THEN\
                    LET l_hdr.rd_prodno = l_prodno\
                END IF\
\
            AFTER FIELD rd_prodno\
                IF l_hdr.rd_prodno IS NULL THEN\
                    ERROR " Product code must be entered! "\
                    NEXT FIELD rd_prodno\
                END IF\
                \
                SELECT pmdesc\
                  INTO l_hdr.pmdesc\
                  FROM product\
                 WHERE pmprodno = l_hdr.rd_prodno\
                IF status != 0 THEN\
                    ERROR " Invalid product code! "\
                    LET l_hdr.rd_prodno = NULL\
                    LET l_hdr.pmdesc = NULL\
                    DISPLAY BY NAME l_hdr.rd_prodno, l_hdr.pmdesc\
                    NEXT FIELD rd_prodno\
                END IF\
                        \{ Added by Frankie Ang for refrig - s \}\
                IF std_is_product_xkit_comp(l_hdr.rd_prodno) THEN\
                    ERROR "Components of Refrigeration Kits Cannot be Selected. Select Refrigeration Kit."\
                    LET l_hdr.rd_prodno = NULL\
                    LET l_hdr.pmdesc = NULL\
                    DISPLAY BY NAME l_hdr.rd_prodno, l_hdr.pmdesc\
                    NEXT FIELD rd_prodno\
                END IF\
                        \{ Added by Frankie Ang for refrig - e \}\
\
                LET l_hdr.rmq = std_get_reece_mult_qty(l_hdr.rd_prodno, "")\
                DISPLAY BY NAME l_hdr.pmdesc, l_hdr.rmq                  \
                MESSAGE ""\
                IF l_prodno IS NULL THEN\
                    LET l_change_sch = FALSE\
                END IF\
		NEXT FIELD scheme\
\
            ON ACTION product_search INFIELD rd_prodno \{F1=Select Product\}\
                IF prod_win() THEN\
                    OPTIONS FORM LINE 3\
                    LET l_hdr.rd_prodno = p_psel.pmprodno\
                    SELECT pmdesc\
                      INTO l_hdr.pmdesc\
                      FROM product\
                     WHERE pmprodno = l_hdr.rd_prodno\
                    IF status != 0 THEN\
                        ERROR " Invalid product code! "\
                        LET l_hdr.rd_prodno = NULL\
                        LET l_hdr.pmdesc = NULL\
                        DISPLAY BY NAME l_hdr.rd_prodno, l_hdr.pmdesc\
                        NEXT FIELD rd_prodno\
                    END IF\
                    \
                    LET l_hdr.rmq = std_get_reece_mult_qty(l_hdr.rd_prodno, "")\
                    \
                    DISPLAY BY NAME l_hdr.rd_prodno, l_hdr.pmdesc, l_hdr.rmq                  \
                END IF\
                \
                OPTIONS FORM LINE 3\
\
            ON ACTION reselect_branch \{F5=Re-select Branch\}\
                LET l_branch_sel = TRUE\
                EXIT INPUT\
\
            AFTER INPUT\
                IF check_del("") THEN\
                    LET l_ok = FALSE\
                    EXIT INPUT\
                END IF\
                \
                IF l_hdr.rd_prodno IS NULL THEN\
                    ERROR " Product code must be entered! "\
                    NEXT FIELD rd_prodno\
                END IF\
\
                IF l_hdr.scheme IS NULL THEN\
                    ERROR " Replenish Scheme must be selected! "\
                    NEXT FIELD scheme\
                END  IF\
        END INPUT\
\
        IF NOT l_ok THEN\
            EXIT WHILE\
        END IF\
\
        IF l_branch_sel THEN\
            CLEAR scr_hdr.*\
            CLEAR scr_prd.*\
            CONTINUE WHILE\
        END IF\
\
        IF NOT l_change_sch THEN\
            -- select all data from replenish_data\
            LET l_query = "SELECT UNIQUE branch.brcode, '', rd_repqty, ",\
                                " rd_effdmy, rd_serialno",\
                          "  FROM branch,  OUTER replenish_data"\
                      \
            IF l_include_showrooms THEN \
                LET l_query = l_query CLIPPED , ' , showroom_detail ' \
            END IF\
  \
            IF LENGTH(l_regionman) > 0 THEN\
                LET l_query = l_query CLIPPED, ", temp_region_branches tmp"\
                CALL replace_word(l_where, "regionman", "tmp.userid") RETURNING l_where\
            END IF\
\
            LET l_query = l_query CLIPPED,\
                          " WHERE ", l_where CLIPPED,\
                          "   AND rd_prodno = '", l_hdr.rd_prodno, "'",\
                          "   AND branch.brcode = rd_brcode",\
                          "   AND brposlive = 'Y'",\
                          "   AND rd_editable = 'N'"\
\
            IF LENGTH(l_hdr.rd_suppstate) > 0 THEN\
                LET l_query = l_query CLIPPED,\
                          "   AND brstate[2] = '", l_hdr.rd_suppstate, "'"\
            END IF\
\
            IF l_include_showrooms THEN\
                LET l_query = l_query CLIPPED, ' AND branch.brcode = sd_brcode'\
            END IF\
\
            IF length(l_butQueryText) > 0 THEN\
                LET l_query = l_query CLIPPED, " AND brorganisation_parent_type = \\"",gc_parentTypeBU,"\\" AND ",\
                                                         " brorganisation_parent_id IN ",\
                                                         " (SELECT bu_id FROM business_unit ",\
                                                         " WHERE ", l_butQueryText CLIPPED\
                    LET l_query = l_query CLIPPED, " )"\
            END IF\
\
            IF LENGTH(l_regionman) > 0 THEN\
                LET l_query = l_query CLIPPED,\
                          "   AND branch.brcode = tmp.brcode"\
            END IF\
\
            LET l_query = l_query CLIPPED,\
                        " ORDER BY brcode"\
\
            PREPARE adallocprep FROM l_query\
            DECLARE adalloccurs CURSOR FOR adallocprep\
\
            LET l_arr_cnt = 1\
        \
            FOREACH adalloccurs INTO l_rdrec.*\
                IF NOT lib_check_isBranch(l_rdrec.brcode) THEN\
                    CONTINUE FOREACH\
                END IF\
\
                LET l_rdarr[l_arr_cnt].* = l_rdrec.*\
                LET l_rdarr[l_arr_cnt].brname = lib_get_branchName(l_rdarr[l_arr_cnt].brcode)\
\
                IF l_rdarr[l_arr_cnt].rd_repqty IS NULL THEN\
                    LET l_rdarr[l_arr_cnt].rd_repqty = 0\
                END IF\
\
                LET l_arr_cnt = l_arr_cnt + 1\
                IF l_arr_cnt > c_arr_max THEN\
                    ERROR " Cannot display more than ", c_arr_max USING "<<<<&",\
                          " records! "\
                    EXIT FOREACH\
                END IF\
            END FOREACH\
            LET l_arr_cnt = l_arr_cnt - 1\
\
            CALL set_count(l_arr_cnt)\
        END IF\
        \
        LET l_prodno = l_hdr.rd_prodno\
        LET p_bs.bsscheme = l_hdr.scheme\
        LET l_change_sch = FALSE\
\
        INPUT ARRAY l_rdarr WITHOUT DEFAULTS FROM scr_arr.* ATTRIBUTES(INSERT ROW=TRUE, DELETE ROW=TRUE, APPEND ROW=TRUE, NORMAL)\
            BEFORE ROW\
                LET l_arr = arr_curr()\
                LET l_scr = scr_line()\
                \
                IF l_arr > 1 AND\
                   l_rdarr[l_arr].rd_repqty = 0 THEN\
\
                    -- Details are null so default the quantity\
                    -- and date to that of the line above.\
                    LET l_rdarr[l_arr].rd_repqty = l_rdarr[l_arr-1].rd_repqty\
\
                    LET l_rdarr[l_arr].rd_effdmy = l_rdarr[l_arr-1].rd_effdmy\
\
                    DISPLAY l_rdarr[l_arr].rd_repqty,\
                            l_rdarr[l_arr].rd_effdmy\
                         TO scr_arr[l_scr].rd_repqty,\
                            scr_arr[l_scr].rd_effdmy                  \
                END IF\
\
            AFTER ROW\
                IF check_del("") THEN\
                    LET l_ok = FALSE\
                    EXIT INPUT\
                END IF\
                IF LENGTH(l_rdarr[l_arr].brcode) > 0 AND\
                   l_rdarr[l_arr].rd_repqty IS NULL THEN\
                    ERROR " Quantity must be entered! "\
                    NEXT FIELD rd_repqty\
                END IF\
                -- Quantity entered must be a multiple of RMQ.\
                IF l_rdarr[l_arr].rd_repqty MOD l_hdr.rmq != 0 THEN\
                    ERROR " Must allocate a multiple of the RMQ "\
                    NEXT FIELD rd_repqty\
                END IF\
\
            BEFORE DELETE\
                IF LENGTH(l_rdarr[l_arr].brcode) > 0 THEN\
                    INSERT INTO tmp_repdata_del\
                        VALUES (l_rdarr[l_arr].rd_serialno)\
                END IF\
                -- This initialise is needed to stop the program from\
                -- locking up when using F2 Delete on a line where a brcode\
                -- has been entered but the quantity is still null.\
                INITIALIZE l_rdarr[l_arr].* TO NULL\
\
            BEFORE FIELD brcode\
                LET l_old_brcode = l_rdarr[l_arr].brcode\
                IF l_arr > 1 THEN\
                    IF l_rdarr[l_arr-1].rd_repqty > 0 AND\
                       LENGTH(l_rdarr[l_arr].brcode) = 0 THEN\
\
                        -- We've created a new line, so default the quantity\
                        -- and date to that of the line above.\
                        LET l_rdarr[l_arr].rd_repqty = l_rdarr[l_arr-1].rd_repqty\
\
                        LET l_rdarr[l_arr].rd_effdmy = l_rdarr[l_arr-1].rd_effdmy\
\
                        DISPLAY l_rdarr[l_arr].rd_repqty,\
                                l_rdarr[l_arr].rd_effdmy\
                             TO scr_arr[l_scr].rd_repqty,\
                                scr_arr[l_scr].rd_effdmy                  \
                    END IF\
                END IF\
\
            AFTER FIELD brcode\
                IF LENGTH(l_rdarr[l_arr].brcode) > 0 THEN\
                    IF NOT lib_check_existsInBranchTable(l_rdarr[l_arr].brcode) THEN\
                        ERROR " Invalid Branch Code! "\
                        NEXT FIELD brcode\
                    END IF\
                    FOR l_idx = 1 TO arr_count()\
                        -- Ensure this branch doesn't already exist\
                        IF l_idx = l_arr THEN CONTINUE FOR END IF\
                        IF LENGTH(l_rdarr[l_arr].brcode) > 0 AND\
                           COMPARE(l_rdarr[l_arr].brcode,\
                                   l_rdarr[l_idx].brcode) THEN\
                            ERROR " Branch record already exists! "\
                            LET l_rdarr[l_arr].brcode = l_old_brcode\
                            DISPLAY l_rdarr[l_arr].brcode\
                                 TO scr_arr[l_scr].brcode                  \
                            NEXT FIELD brcode\
                        END IF\
                    END FOR\
                    IF NOT COMPARE(l_old_brcode, l_rdarr[l_arr].brcode) THEN\
                        -- Check record already exists in table\
                        LET l_brcode = NULL\
                        LET l_qty = NULL\
                        SELECT rd_brcode, rd_repqty\
                          INTO l_brcode, l_qty\
                          FROM replenish_data\
                         WHERE rd_prodno = l_hdr.rd_prodno\
                           AND rd_brcode = l_rdarr[l_arr].brcode\
                        IF status = 0 THEN\
                            CALL lib_get_branchName(l_rdarr[l_arr].brcode)\
                                 RETURNING l_rdarr[l_arr].brname\
\
                            LET l_rdarr[l_arr].brcode = l_brcode\
                            LET l_rdarr[l_arr].rd_repqty = l_qty\
\
                            DISPLAY l_rdarr[l_arr].*\
                                     TO scr_arr[l_scr].*                  \
                            NEXT FIELD rd_repqty\
                        ELSE\
                            LET l_rdarr[l_arr].rd_repqty = 0\
                        END IF\
                    END IF\
                END IF\
\
                IF LENGTH(l_rdarr[l_arr].brcode) = 0 AND\
                   NOT going("accept") AND\
                   NOT going_up() THEN\
                    ERROR " Branch Code must be entered! "\
                    NEXT FIELD brcode\
                END IF\
                LET l_rdarr[l_arr].brname = lib_get_branchName(l_rdarr[l_arr].brcode)\
                DISPLAY l_rdarr[l_arr].brname\
                     TO scr_arr[l_scr].brname                  \
\
            AFTER FIELD rd_repqty\
                -- Quantity entered must be a multiple of RMQ.\
                LET l_qty_int = l_rdarr[l_arr].rd_repqty\
                LET l_rdarr[l_arr].rd_repqty = l_qty_int\
                DISPLAY l_rdarr[l_arr].rd_repqty\
                     TO scr_arr[l_scr].rd_repqty                  \
                IF l_rdarr[l_arr].rd_repqty MOD l_hdr.rmq != 0 THEN\
                    ERROR " Must allocate a multiple of the RMQ "\
                    NEXT FIELD rd_repqty\
                END IF\
\
            AFTER FIELD rd_effdmy\
                -- Effective date cannot be in the past\
                IF l_rdarr[l_arr].rd_effdmy < TODAY THEN\
                    ERROR " Effective Date cannot be in the past! "\
                    NEXT FIELD rd_effdmy\
                END IF\
\
            ON ACTION branch_searchf5 INFIELD brcode \{F5=Select Branch\}\
                    IF branch_win("") THEN\
                        LET l_rdarr[l_arr].brcode = p_bsel.brcode\
                        IF NOT lib_check_existsInBranchTable(l_rdarr[l_arr].brcode) THEN\
                            DISPLAY "" TO scr_arr[l_scr].brname\
                            ERROR " Invalid branch code! "\
                            NEXT FIELD brcode\
                        END IF\
                        LET l_rdarr[l_arr].brname = lib_get_branchName(l_rdarr[l_arr].brcode)\
                        DISPLAY l_rdarr[l_arr].brcode,\
                                l_rdarr[l_arr].brname\
                             TO scr_arr[l_scr].brcode,\
                                scr_arr[l_scr].brname                  \
                    END IF\
\
            ON ACTION default_all \{F6=Default All\}\
                IF LENGTH(l_rdarr[l_arr].brcode) > 0 THEN\
                    LET l_rdarr[l_arr].rd_repqty = get_fldbuf(rd_repqty)\
                    LET l_rdarr[l_arr].rd_effdmy = get_fldbuf(rd_effdmy)\
                    -- Quantity entered must be a multiple of RMQ.\
                    LET l_qty_int = l_rdarr[l_arr].rd_repqty\
                    LET l_rdarr[l_arr].rd_repqty = l_qty_int\
                    DISPLAY l_rdarr[l_arr].rd_repqty\
                         TO scr_arr[l_scr].rd_repqty                  \
                    IF l_rdarr[l_arr].rd_repqty MOD l_hdr.rmq != 0 THEN\
                        ERROR " Must allocate a multiple of the RMQ "\
                        NEXT FIELD rd_repqty\
                    END IF\
                    -- Effective date cannot be in the past\
                    IF l_rdarr[l_arr].rd_effdmy < TODAY THEN\
                        ERROR " Effective Date cannot be in the past! "\
                        NEXT FIELD rd_effdmy\
                    END IF\
                    FOR l_idx = 1 TO arr_count()\
                        IF l_arr = l_idx THEN\
                            CONTINUE FOR\
                        END IF\
                        LET l_rdarr[l_idx].rd_repqty = l_rdarr[l_arr].rd_repqty\
                        LET l_rdarr[l_idx].rd_effdmy = l_rdarr[l_arr].rd_effdmy\
                    END FOR\
                    LET l_cnt = 0\
                    FOR l_idx = (l_arr-l_scr+1) TO (l_arr-l_scr+c_scr_max)\
                        LET l_cnt = l_cnt + 1\
                        DISPLAY l_rdarr[l_idx].*\
                             TO scr_arr[l_cnt].*                  \
                    END FOR\
                END IF\
\
            ON ACTION change_scheme \{F7=Change Scheme\}\
                LET l_branch_sel = FALSE\
                LET l_cont = TRUE\
                LET l_change_sch = TRUE\
                CONTINUE WHILE\
\
            ON ACTION CANCEL\
               LET l_ok = FALSE\
               MESSAGE "Admin Allocatted Stock cancelled."\
               EXIT INPUT\
\
            AFTER INPUT\
                IF check_del("") THEN\
                    LET l_ok = FALSE\
                    EXIT INPUT\
                END IF\
                LET l_arr = arr_count()\
\
        END INPUT\
\
        IF NOT l_ok THEN\
            CLEAR scr_prd.*\
            FOR l_arr = 1 TO c_scr_max\
                CLEAR scr_arr[l_arr].*\
            END FOR\
            CONTINUE WHILE\
        END IF\
\
        -- Save changes to replenish_data\
        DECLARE rdatacur CURSOR FOR\
         SELECT rd_serialno\
           FROM tmp_repdata_del\
        FOREACH rdatacur INTO l_serialno\
            LET p_exec = "c1. replenish_data removed - ", l_serialno\
            CALL errorlog(p_exec)\
\
            DELETE FROM replenish_data\
                  WHERE rd_serialno = l_serialno\
        END FOREACH\
\
        -- Update replenish_data\
        FOR l_idx = 1 TO l_arr\
            IF LENGTH(l_rdarr[l_idx].brcode) > 0 AND l_rdarr[l_idx].rd_repqty > 0 THEN\
                -- Check a valid bstock row exists for this product,\
                -- with a valid scheme.  If not, default scheme to 'S'\
                IF std_get_bstock_row(l_rdarr[l_idx].brcode, l_hdr.rd_prodno) THEN\
                    -- No bstock row exists, so need to create a new\
                    -- one using the data that the standard just\
                    -- created into p_bs.*\
                    CALL std_insert_bstock_row() RETURNING l_notused\
     \
                    LET l_scheme_recalc = TRUE\
                    LET p_bs.bsscheme   = l_hdr.scheme\
                ELSE\
                    -- A bstock row was found, so need to check that it\
                    -- has a valid scheme set (4, 2, M or D)\
                    IF (p_bs.bsscheme MATCHES "[42M1FOT]" OR p_bs.bsscheme = "12") AND\
                       p_bs.bsscheme IS NOT NULL THEN\
                        -- Scheme is valid, we don't need to do anything\
                        LET l_scheme_recalc = FALSE\
                    ELSE\
                        -- Scheme is invalid for admin allocated, so\
                        -- default it to scheme 4 and recalculate min/max\
                        -- This will purposefully overwrite schemes N, T & S\
                        LET l_scheme_recalc = TRUE\
                        LET p_bs.bsscheme   = l_hdr.scheme\
                    END IF\
                END IF\
\
                IF p_bs.bsscheme MATCHES "[NS]" THEN\
                    LET l_rd.rd_ptype = "R"\
                ELSE\
                    LET l_rd.rd_ptype = "S"\
                END IF\
\
                UPDATE replenish_data\
                   SET rd_repqty = l_rdarr[l_idx].rd_repqty,\
                       rd_effdmy = l_rdarr[l_idx].rd_effdmy,\
                       rd_ptype  = l_rd.rd_ptype\
                 WHERE rd_serialno = l_rdarr[l_idx].rd_serialno\
\
                IF status != 0 OR\
                   SQLCA.SQLERRD[3] = 0 THEN\
                    LET l_rd.rd_brcode         = l_rdarr[l_idx].brcode\
                    LET l_rd.rd_prodno         = l_hdr.rd_prodno\
                    LET l_rd.rd_prbasis        = 1\
                    LET l_rd.rd_repqty         = l_rdarr[l_idx].rd_repqty\
                    LET l_rd.rd_suppno         = NULL\
                    LET l_rd.rd_suppstate      = NULL\
                    LET l_rd.rd_suppname       = NULL\
                    LET l_rd.rd_spadd1         = NULL\
                    LET l_rd.rd_spadd2         = NULL\
                    LET l_rd.rd_spadd3         = NULL\
                    LET l_rd.rd_sppcode        = NULL\
                    LET l_rd.rd_spphone        = NULL\
                    LET l_rd.rd_spfax          = NULL\
                    LET l_rd.rd_agentno        = NULL\
                    LET l_rd.rd_fullreb        = NULL\
                    LET l_rd.rd_rebcst         = NULL\
                    LET l_rd.rd_invcst         = NULL\
                    LET l_rd.rd_rebset         = NULL\
                    LET l_rd.rd_ovrcost        = NULL\
                    LET l_rd.rd_effdmy         = l_rdarr[l_idx].rd_effdmy\
                    LET l_rd.rd_syslec         = NULL\
                    LET l_rd.rd_bestcost       = NULL\
                    LET l_rd.rd_bestrebcst     = NULL\
                    LET l_rd.rd_bestinvcst     = NULL\
                    LET l_rd.rd_bestsyslec     = NULL\
                    LET l_rd.rd_bestsupp       = NULL\
                    LET l_rd.rd_partno         = NULL\
                    LET l_rd.rd_countme        = "N"\
                    LET l_rd.rd_editable       = "N"\
                    LET l_rd.rd_report_section = NULL\
                    LET l_rd.rd_runout_date    = NULL\
                    LET l_rd.rd_origin         = "A"\
                    LET l_rd.rd_serialno       = 0\
                    LET l_rd.rd_hold           = "N"\
\
                    SELECT bsohdqty\
                      INTO l_rd.rd_ohdqty\
                      FROM bstock\
                     WHERE bsprodno = l_hdr.rd_prodno\
                       AND bswhse   = l_rdarr[l_idx].brcode\
                    IF status != 0 THEN\
                        LET l_rd.rd_ohdqty = 0\
                    END IF\
\
                    SELECT pmgrp\
                      INTO l_rd.rd_grp\
                      FROM product\
                     WHERE pmprodno = l_hdr.rd_prodno\
\
                    CALL errorlog(l_rd.rd_prodno)\
                    CALL errorlog(l_rd.rd_brcode)\
                    CALL errorlog(p_uid.iduserid)\
\
                    INSERT INTO replenish_data VALUES (l_rd.*)\
                END IF\
\
                IF l_scheme_recalc THEN\
                    CALL std_get_mult_qty(l_rdarr[l_idx].brcode, "", l_hdr.rd_prodno) RETURNING l_notused, l_rmq\
\
                    CALL std_calc_avg_sales_sms2(l_rdarr[l_idx].brcode, l_hdr.rd_prodno, '', FALSE) RETURNING l_notused, l_forecast, l_notused\
 \
                    CALL std_calc_min_max_settings(p_bs.bsscheme, l_hdr.rd_prodno, l_rdarr[l_idx].brcode, l_forecast, FALSE)\
                         RETURNING p_bs.bsminqty, p_bs.bsmaxqty\
                \
                    LET p_bs.bssys_calcdate = TODAY\
                    LET p_bs.bsschemesetdmy = TODAY\
\
                    IF p_bs.bsscheme = "2" THEN\
                        LET l_ocf = 0.5\
                    ELSE\
                        LET l_ocf = 1\
                    END IF\
\
                    UPDATE bstock\
                       SET bsscheme       = p_bs.bsscheme,\
                           bsminqty       = p_bs.bsminqty,\
                           bsmaxqty       = p_bs.bsmaxqty,\
                           bssys_minqty   = p_bs.bsminqty,\
                           bssys_maxqty   = p_bs.bsmaxqty,\
                           bssys_calcdate = p_bs.bssys_calcdate,\
                           bssys_avg2ws   = l_2ws,\
                           bssys_ocf      = l_ocf,\
                           bsschemesetdmy = p_bs.bsschemesetdmy\
                     WHERE bswhse   = l_rdarr[l_idx].brcode\
                       AND bsprodno = l_hdr.rd_prodno\
                    IF status != 0 THEN\
                        LET l_msg = "Could not update bstock row (", l_hdr.rd_prodno, "-", l_rdarr[l_idx].brcode, ")"\
                        CALL errorlog(l_msg)\
                    END IF\
                END IF\
            END IF\
        END FOR\
\
        -- Return to the header input.\
        CLEAR scr_prd.*\
        FOR l_arr = 1 TO c_scr_max\
            CLEAR scr_arr[l_arr].*\
        END FOR\
\
        IF l_ok THEN\
            MESSAGE "Admin Allocated Stock completed."\
        END IF\
    END WHILE\
\
END FUNCTION\
\
\{******************************************************************************\}\
\
FUNCTION show_replen_schedule(l_brcode)\
\
 DEFINE l_brcode                       LIKE branch.brcode,\
        l_brname                       LIKE branch.brname,\
        l_start, l_end                      DATE,\
        l_repl DYNAMIC ARRAY OF RECORD\
            ezday                           CHAR(3),\
            ezdate                          DATE,\
            replenishGroup                  VARCHAR(150),\
            eztime                          CHAR(5)\
        END RECORD,\
        c_arr_max                           SMALLINT,\
        l_cnt, l_notused                    SMALLINT,\
        l_idx                               SMALLINT,\
        l_dcid                              CHAR(4),\
        l_dcdesc                            CHAR(20),\
        l_ok                                SMALLINT,\
        l_whse_count                        INTEGER\
\
    LET c_arr_max = 30                  \{* l_repl array maximum *\}\
    INITIALIZE l_repl TO NULL\
\
    LET l_start = TODAY\
    LET l_end = l_start + 30 UNITS DAY\
\
    LET l_cnt = 0\
\
    OPEN WINDOW repschedwin WITH FORM "por1100_warehouseReplenishmentSchedule"\
    CALL lib_set_form_toolbar("Page")\
\
    LET l_brname = lib_get_branchName(l_brcode)\
\
    WHILE(TRUE)\
\
    DISPLAY l_brcode, l_brname TO brcode, brname                  \
    DISPLAY l_dcdesc TO dcdesc                  \
\
    LET l_cnt = 0\
\
    INPUT l_dcid  WITHOUT DEFAULTS FROM dcid                  \
\
        AFTER FIELD dcid\
            IF l_dcid IS NULL THEN\
                ERROR "Whse Number must be entered"\
                NEXT FIELD dcid\
            END IF\
\
            IF NOT std_pickingScheduleAllowed(l_dcid) THEN\
                ERROR "Invalid Whse Number"\
                NEXT FIELD dcid\
            END IF\
\
            LET l_dcdesc = lib_get_branchName(l_dcid)\
            DISPLAY l_dcid TO dcid                  \
            DISPLAY l_dcdesc TO dcdesc                  \
            \
        AFTER INPUT\
            IF going_up() THEN\
                NEXT FIELD dcid\
            END IF\
    END INPUT\
\
    CALL getWarehouseReplenishmentDays(l_brcode, l_dcid) RETURNING l_repl\
\
    IF check_del("") THEN\
        LET l_ok = FALSE\
        EXIT WHILE\
    END IF\
\
    IF l_repl.getLength() = 0 THEN\
        CLEAR FORM\
        ERROR " No Scheduled Replenishments found! "\
        \{Call 73502 - Exit if no DC Schedule or only 1 DC schedule, or the program will go into an infinite loop\}\
        IF l_whse_count <= 1 THEN\
            EXIT WHILE\
        ELSE\
            CONTINUE WHILE\
        END IF\
        RETURN\
    END IF\
\
    FOR l_idx = 1 TO l_repl.getLength()\
        CALL lib_get_ludesc("WD",WEEKDAY(l_repl[l_idx].ezdate)) RETURNING l_repl[l_idx].ezday\
    END FOR\
\
    LET l_ok = TRUE\
    \
    DISPLAY ARRAY l_repl TO scr_arr.*                  \
\
        AFTER DISPLAY\
            IF check_del("") THEN\
                LET l_ok = FALSE\
                EXIT DISPLAY\
            END IF\
    END DISPLAY\
\
    IF NOT l_ok THEN\
        EXIT WHILE\
    END IF\
\
    END WHILE\
\
    CLOSE WINDOW repschedwin\
\
    CALL check_del("") RETURNING l_notused\
\
END FUNCTION\
--------------------------------------------------------------------------------\
\
FUNCTION getWarehouseReplenishmentDays(l_branchNumber, l_warehousenumber)\
\
 DEFINE l_branchNumber                  LIKE branch.brcode,\
        l_warehouseNumber               LIKE branch.brcode,\
        x                                    INTEGER,\
        l_deliveryZoneID                LIKE whse_delivery_zone_branch.wdzb_delivery_zone_id,\
        l_date                               DATE,\
        l_day                                SMALLINT,\
        l_groupDescription                   VARCHAR(150),\
        l_replenishAction               LIKE whse_delivery_link_schedule.wdls_branch_replenish,\
        l_linkID                        LIKE whse_delivery_link.wdl_id,\
        l_groupID                       LIKE whse_delivery_link.wdl_group_id,\
        l_repl DYNAMIC ARRAY OF RECORD\
            ezday                            CHAR(3),\
            ezdate                           DATE,\
            replenishGroup                   VARCHAR(150),\
            eztime                           CHAR(5)\
        END RECORD,\
        l_count                              INTEGER\
\
    LET l_date  = TODAY\
    LET l_count = 1\
\
    FOR x = 1 TO 30\
        LET l_day  = WEEKDAY(l_date)\
        \
        DECLARE replenishDays CURSOR FOR\
         SELECT wdg_code, wdl_id, wdl_group_id\
           INTO l_deliveryZoneID\
           FROM whse_delivery_zone_branch, whse_delivery_zone, whse_delivery_link_schedule, whse_delivery_link, \
                whse_delivery_group\
          WHERE wdzb_branch_code      = l_branchNumber\
            AND wdz_whse_code         = l_warehousenumber \
            AND wdls_day_of_week      = l_day\
            AND wdls_link_id          = wdl_id\
            AND wdzb_delivery_zone_id = wdz_id\
            AND wdls_branch_replenish = 'Y'\
            AND wdl_group_id          = wdg_id\
            AND wdl_zone_id           = wdzb_delivery_zone_id\
        FOREACH replenishDays INTO l_groupDescription, l_linkID, l_groupID\
             SELECT wdlsi_branch_replenish_action\
               INTO l_replenishAction\
               FROM whse_delivery_link, whse_delivery_link_special_instruction\
              WHERE wdlsi_branch_replenish_action = "N"\
                AND wdlsi_link_id                 = wdl_id  \
                AND wdlsi_date                    = l_date\
                AND wdl_id  = l_linkID\
            IF STATUS = 0 AND l_replenishAction = "N" THEN\
                -- Replenishment withheld, continue search\
                CONTINUE FOREACH\
            END IF\
\
            IF l_count > 1 THEN\
                IF l_repl[l_count-1].ezdate = l_date THEN\
                    LET l_groupDescription = SFMT('%1 & %2', l_repl[l_count-1].replenishGroup CLIPPED, l_groupDescription)\
                    LET l_count = l_count-1\
                END IF\
            END IF\
            \
            LET l_repl[l_count].ezday          = l_day\
            LET l_repl[l_count].ezdate         = l_date\
            LET l_repl[l_count].replenishGroup = l_groupDescription\
            LET l_repl[l_count].eztime         = TIME \
\
            IF std_check_branch_holiday(l_branchNumber, l_repl[l_count].ezdate) OR  -- Holiday\
               WEEKDAY(l_repl[l_count].ezdate) = 0 OR                               -- Sunday\
               WEEKDAY(l_repl[l_count].ezdate) = 6 THEN                             -- Saturday\
                -- The date we have is either a weekend or a public holiday so check the day before.\
                LET l_repl[l_count].ezdate = l_repl[l_count].ezdate - 1 UNITS DAY\
\
                IF l_count > 1 THEN\
                    IF l_repl[l_count].ezdate =  l_repl[l_count-1].ezdate THEN\
                        LET l_groupDescription = SFMT('%1 & %2', l_repl[l_count-1].replenishGroup CLIPPED, l_groupDescription)\
                        LET l_count = l_count-1\
                        LET l_repl[l_count].replenishGroup = l_groupDescription\
                    END IF\
                END IF\
            END IF \
\
            LET l_count = l_count + 1        \
        END FOREACH\
\
        \
        DECLARE replenishDateSpecialRequirements CURSOR FOR\
         SELECT wdlsi_date, wdg_code \
           FROM whse_delivery_link, whse_delivery_zone_branch, whse_delivery_link_special_instruction, whse_delivery_zone,\
                whse_delivery_group\
          WHERE wdlsi_branch_replenish_action = "Y"\
            AND wdl_zone_id                   = wdzb_delivery_zone_id\
            AND wdzb_branch_code              = l_branchNumber\
            AND wdlsi_date                    = l_date\
            AND wdl_id                        = wdlsi_link_id\
            AND wdzb_delivery_zone_id         = wdl_zone_id\
            AND wdz_whse_code                 = l_warehousenumber\
            AND wdl_group_id                  = wdg_id\
            AND wdz_id                        = wdl_zone_id\
        FOREACH replenishDateSpecialRequirements INTO l_repl[l_count].ezdate, l_groupDescription\
            IF l_count > 1 THEN\
                IF l_repl[l_count-1].ezdate = l_date THEN\
                    LET l_groupDescription = SFMT('%1 & %2', l_repl[l_count-1].replenishGroup CLIPPED, l_groupDescription)\
                    LET l_count = l_count-1\
                END IF\
            END IF\
\
            LET l_repl[l_count].ezday          = l_day\
            LET l_repl[l_count].ezdate         = l_date\
            LET l_repl[l_count].replenishGroup = l_groupDescription\
            LET l_repl[l_count].eztime         = TIME \
\
            IF std_check_branch_holiday(l_branchNumber, l_repl[l_count].ezdate) OR  -- Holiday\
               WEEKDAY(l_repl[l_count].ezdate) = 0 OR                               -- Sunday\
               WEEKDAY(l_repl[l_count].ezdate) = 6 THEN                             -- Saturday\
                -- The date we have is either a weekend or a public holiday so check the day before.\
                LET l_repl[l_count].ezdate = l_repl[l_count].ezdate - 1 UNITS DAY\
\
                IF l_count > 1 THEN\
                    IF l_repl[l_count].ezdate = l_date THEN\
                        LET l_groupDescription = SFMT('%1 & %2', l_repl[l_count-1].replenishGroup CLIPPED, l_groupDescription)\
                        LET l_count = l_count-1\
                        LET l_repl[l_count].replenishGroup = l_groupDescription\
                    END IF\
                END IF\
            END IF  \
\
            LET l_count = l_count + 1\
\
        END FOREACH\
\
        LET l_date = l_date + 1 UNITS DAY\
    END FOR\
\
    CALL l_repl.deleteElement(l_count)\
\
    RETURN l_repl\
\
END FUNCTION\
\{*********************************************************************************************************************\}\
\{* settings_data: Produce comparative output on particular products between old and new order quantity formulae      *\}\
\{*                                                                                                                   *\}\
\{*   Pass - p_uid.idtype:   User type; Must be head Office user ("H")                                                *\}\
\{*          p_uid.idemail:  User email address; User must have an email address                                      *\}\
\{*                                                                                                                   *\}\
\{*   Returns - Nil                                                                                                   *\}\
\{*                                                                                                                   *\}\
\{*********************************************************************************************************************\}\
\
FUNCTION settings_data()\
\
 DEFINE l_where                         CHAR(100),\
        l_start_ticode                  INTEGER,\
        l_end_ticode                    INTEGER,\
        l_msg                           CHAR(100),\
        l_month                         SMALLINT,\
        l_year                          SMALLINT\
\
 DEFINE l_sales_period              STRING,\
        l_email_repto           STRING\
\
    \{-------------------------------------------------------------------------------------------------------\}\
\
    IF LENGTH(p_uid.idemail) = 0 THEN       -- User must have email address.\
        ERROR " Cannot run Stock Settings Data report: No valid email address found! "\
        LET l_msg = "por1100 ", p_uid.iduserid ," - Cannot run Stock Settings Data report: No valid email address found! "\
        CALL errorlog(l_msg CLIPPED)\
        RETURN\
    END IF\
\
    \{-------------------------------------------------------------------------------------------------------\}\
    -- Determine run period\
    LET l_month = MONTH(TODAY)\
    LET l_year = YEAR(TODAY)\
    LET l_month = l_month - 1\
    IF l_month < 1 THEN\
        LET l_month = 12\
        LET l_year = l_year - 1\
    END IF\
    LET l_end_ticode = (l_year * 100) + l_month\
\
    LET l_month = l_month + 1\
    LET l_year = l_year - 1\
    IF l_month > 12 THEN\
        LET l_month = 1\
        LET l_year = l_year + 1\
    END IF\
    LET l_start_ticode = (l_year * 100) + l_month\
\
    \{-------------------------------------------------------------------------------------------------------\}\
    -- Open interface and accept input\
    OPEN FORM ssd_form FROM "por1100_stockSettingsDataReport" \
    DISPLAY FORM ssd_form \
    CALL lib_set_form_toolbar("Basic")\
\
    LET l_sales_period = "Sales Period: ", l_start_ticode USING "<&&&&&&", " to ", l_end_ticode USING "<&&&&&&"\
    DISPLAY l_sales_period TO lbl_sales_period \
    LET l_email_repto = "Email Report to: ", p_uid.idemail CLIPPED\
    DISPLAY l_email_repto TO lbl_email_repto                  \
\
    WHILE(TRUE)\
\
        CONSTRUCT BY NAME l_where ON bswhse, pmgrp, pmsubgrp, bsprodno, bsscheme, bsminqty, bsmaxqty                  \
\
        IF check_del("") THEN\
            EXIT WHILE\
        END IF\
\
        IF COMPARE(l_where, " 1=1") THEN\
            ERROR " Cannot do a query on all records! "\
            CONTINUE WHILE\
        END IF\
\
        IF NOT string_in(l_where, "bswhse") THEN\
            ERROR " Branch code(s) must be designated! "\
            CONTINUE WHILE\
        END IF\
\
        IF delay_start("1900", FALSE, FALSE) THEN\
                CALL settings_data_report(l_where, l_start_ticode, l_end_ticode)\
        END IF\
\
    END WHILE\
\
    CLOSE FORM ssd_form\
\
END FUNCTION\
\
\{*********************************************************************************************************************\}\
\{* settings_data_report: Stock Settings Data Report generation and email.                                            *\}\
\{*                                                                                                                   *\}\
\{*   Pass - l_where:        SQL Query where part                                                                     *\}\
\{*          l_start_ticode: Time code of start of analysis period                                                    *\}\
\{*          l_end_ticode:   Time code of end of analysis period                                                      *\}\
\{*                                                                                                                   *\}\
\{*   Returns - Nil                                                                                                   *\}\
\{*                                                                                                                   *\}\
\{*********************************************************************************************************************\}\
\
FUNCTION settings_data_report(l_where, l_start_ticode, l_end_ticode)\
\
 DEFINE l_where                         CHAR(100),\
        l_start_ticode                  INTEGER,\
        l_end_ticode                    INTEGER,\
        l_query                         CHAR(500),\
        l_bs RECORD                LIKE bstock.*,\
        l_rec RECORD\
            brcode                 LIKE bstock.bswhse,\
            brname                 LIKE branch.brname,\
            prodno                 LIKE bstock.bsprodno,\
            pmdesc                 LIKE product.pmdesc,\
            grp                    LIKE product.pmgrp,\
            stnname                LIKE lukup.ludesc,\
            subgrp                 LIKE product.pmsubgrp,\
            catname                LIKE lukup.ludesc,\
            m1                     LIKE stocksales.ssqty,\
            m2                     LIKE stocksales.ssqty,\
            m3                     LIKE stocksales.ssqty,\
            m4                     LIKE stocksales.ssqty,\
            m5                     LIKE stocksales.ssqty,\
            m6                     LIKE stocksales.ssqty,\
            m7                     LIKE stocksales.ssqty,\
            m8                     LIKE stocksales.ssqty,\
            m9                     LIKE stocksales.ssqty,\
            m10                    LIKE stocksales.ssqty,\
            m11                    LIKE stocksales.ssqty,\
            m12                    LIKE stocksales.ssqty,\
            class                  LIKE bstock.bsinvclass,\
            mad                    LIKE bstock.bssys_mad12,\
            rmq                    LIKE product.pmmultqty,\
            scheme                 LIKE bstock.bsscheme,\
            mincurr                LIKE bstock.bsminqty,\
            maxcurr                LIKE bstock.bsmaxqty,\
            soh                    LIKE bstock.bsohdqty,\
            son                    LIKE bstock.bsonordqty,\
            fullreb                LIKE bstock.bsunitcost,\
            sohvalue               LIKE bstock.bsunitcost,\
            uom                    LIKE product.pmunits,\
            ratio                  LIKE product.pmratio,\
            binloc                 LIKE binloc.blloc,\
            prefSupplier           LIKE supplier.spsuppno,\
            prefSupplierName       LIKE supplier.spname,\
            source                      STRING,\
            seasonalFlag           LIKE bstock.bsseasonal_product,\
            prodsuspend            LIKE bstock.bsposuspend,\
            autoscheme             LIKE bstock.bsautoscheme,\
            reviewFlag             LIKE sms_monthly_forecasts_review.smfr_review_flag\
        END RECORD,\
        l_idx                           SMALLINT,\
        l_count                         INTEGER,\
        l_total_sales              LIKE stocksales.ssqty,\
        l_total_6                  LIKE stocksales.ssqty,\
        l_months12                      SMALLINT,\
        l_months6                       SMALLINT,\
        l_maxsales                 LIKE stocksales.ssqty,\
        l_2ndmaxsales              LIKE stocksales.ssqty,\
        l_first                         SMALLINT,\
        l_exec                          STRING,\
        l_ticode, l_ssticode       LIKE stocksales.ssticode,\
        l_qty                      LIKE stocksales.ssqty,\
        l_filename                      STRING,\
        l_mth                           SMALLINT,\
        l_ok                            SMALLINT,\
        l_report_count                  INTEGER,\
        l_email RECORD\
            to_address		            CHAR(150),\
            to_cc_email	            	CHAR(300),\
            to_name		                CHAR(80),\
            from_address	            CHAR(150),\
            from_name		            CHAR(80),\
            subject		                CHAR(80),\
            message_filename            CHAR(100),\
            body                        STRING,\
            send_now		            SMALLINT,\
            delivery_type		        CHAR(1)\
        END RECORD,\
        l_month_desc                    CHAR(3),\
        l_grp                      LIKE product.pmgrp,\
        l_subgrp                   LIKE product.pmsubgrp,\
        l_uom                      LIKE product.pmunits,\
        l_brname                   LIKE branch.brname,\
        l_pmdesc                   LIKE product.pmdesc,\
        l_ratio                    LIKE product.pmratio,\
        l_stncat                   LIKE lukup.lucode,\
        l_stage                         SMALLINT,\
        l_stage_count                   INTEGER,\
        l_notused                       INTEGER,\
        l_notused_c                     CHAR(1),\
        l_obunrelqty               LIKE orderbank.obunrelqty,\
        l_branchTypeCode           LIKE branch_type.bt_code,\
        l_kitflg                   LIKE product.pmkitflg,\
        l_data RECORD\
            suppno                 LIKE supplier.spsuppno,\
            suppstate              LIKE supplier.spstate,\
            fullreb                LIKE polines.plunitcost,\
            rebcst                 LIKE polines.plrebcost,\
            invcst                 LIKE polines.plinvcost,\
            syslec                 LIKE polines.plsyslec,\
            rebset                      CHAR(3),\
            partno                 LIKE bg_suppcost.bgpartno,\
            boxqty                 LIKE bg_suppcost.bgbox_qty,\
            kiterr                      SMALLINT,\
            purchplonly            LIKE bg_suppcost.bgpurch_p1_only,\
            multqty                LIKE product.pmmultqty\
        END RECORD,\
        l_hubBranch                LIKE branch.brcode,\
        l_monthlyForecast DYNAMIC ARRAY OF RECORD\
            smsForecast            LIKE sms_monthly_sales_forecasts.smsf_forecasts_qty,\
            branchForecast         LIKE sms_monthly_sales_forecasts.smsf_overridden_forecasts_qty\
        END RECORD,\
        l_date                          DATE\
\
    -- Prepare email\
    CALL std_emailInit()\
    CALL std_getEmailStageName("formula_model", "CSV") RETURNING l_ok, l_filename\
    IF NOT l_ok THEN\
        ERROR " Error occured generating email file - Aborting. "\
        RETURN\
    END IF\
\
    IF NOT std_createtext(l_filename) THEN\
        DISPLAY " Cannot create " || l_filename.trim()\
        RETURN\
    END IF\
\
    -- Create output CSV file and headings.\
    LET l_exec = "Branch code,Branch name,Product code,Product desc,Section,Stn Desc,Category,Cat desc,"\
\
    LET l_mth = l_start_ticode MOD 100\
    FOR l_idx = 1 TO 12\
\
        SELECT ludesc[1,3]\
          INTO l_month_desc\
          FROM lukup\
         WHERE lutabid = "MN"\
           AND lucode = l_mth\
\
        LET l_exec = l_exec CLIPPED, l_month_desc, ","\
        LET l_mth = l_mth + 1\
        IF l_mth > 12 THEN\
            LET l_mth = 1\
        END IF\
\
    END FOR\
\
    LET l_exec = l_exec CLIPPED, "Classification,MAD,RMQ,Scheme,Min,Max,SoH,SoO,",\
                                 "Fully Reb Cost,SoH Value,",\
                                 "UoM (pack 1),Ratio,BinLoc,MAD3,OB,Preferred Supplier,Supplier Name,Source,Seasonal,Product Suspend,Auto Scheme Allocation,",\
                                 "Review Flag,SMS Forecast 1,SMS Forecast 2,SMS Forecast 3,SMS Forecast 4,SMS Forecast 5,SMS Forecast 6,",\
                                 "SMS Forecast 7,SMS Forecast 8,SMS Forecast 9,SMS Forecast 10,SMS Forecast 11,SMS Forecast 12,",\
                                 "Branch Forecast 1,Branch Forecast 2,Branch Forecast 3,Branch Forecast 4,Branch Forecast 5,Branch Forecast 6,",\
                                 "Branch Forecast 7,Branch Forecast 8,Branch Forecast 9,Branch Forecast 10,Branch Forecast 11,Branch Forecast 12"\
    CALL std_writetext(l_exec)\
\
    ------ Query bstock table -------------------------------------------------------------------------------\
\
    LET l_query = "SELECT bstock.*, product.pmgrp, product.pmsubgrp, product.pmunits, ",\
                                   "brname, product.pmratio, product.pmdesc",\
                  "  FROM bstock, branch, product",\
                  " WHERE bsprodno = pmprodno",\
                  "   AND bswhse = brcode",\
#                 "   AND brrepllive = 'Y'",\
                  "   AND bsscheme IN ('4','2','M','D','T','1','12','F','O')",\
                  "   AND ", l_where CLIPPED,\
                  " ORDER BY bswhse"\
    PREPARE pmqry FROM l_query\
    DECLARE pmcur CURSOR FOR pmqry\
\
    LET l_report_count = 0\
    MESSAGE "Generating Report..."\
    LET l_stage = progress_dial(1)\
    LET l_stage_count = 0\
\
    FOREACH pmcur INTO l_bs.*, l_grp, l_subgrp, l_uom, l_brname, l_ratio, l_pmdesc\
\
        CALL l_monthlyForecast.clear()\
        \
        LET l_stage_count = l_stage_count + 1\
        IF l_stage_count MOD 10 = 0 THEN\
            LET l_stage = progress_dial(l_stage)\
        END IF\
\
        -- Initialise variables...\
        LET l_count           = 0       -- stores number of months of data found in stocksales\
        LET l_total_sales     = 0       -- stores total sales over the whole analysis period (6 months)\
        LET l_total_6         = 0       -- stores total sales over the whole analysis period (6 months)\
        LET l_months12        = 0       -- stores number of months from the first stocksales record found to end date\
        LET l_months6         = 0       -- stores number of months from the first stocksales record found to end date\
        LET l_maxsales        = 0       -- stores highest sales value for a given month in the analysis period\
        LET l_2ndmaxsales     = 0       -- stores second highest sales vlue for a given month in the analysis period\
        LET l_first = TRUE\
\
        INITIALIZE l_rec TO NULL\
        LET l_rec.m1  = 0\
        LET l_rec.m2  = 0\
        LET l_rec.m3  = 0\
        LET l_rec.m4  = 0\
        LET l_rec.m5  = 0\
        LET l_rec.m6  = 0\
        LET l_rec.m7  = 0\
        LET l_rec.m8  = 0\
        LET l_rec.m9  = 0\
        LET l_rec.m10 = 0\
        LET l_rec.m11 = 0\
        LET l_rec.m12 = 0\
\
        ------ Get sales information for product ------------------------------------------------------------\
\
        DECLARE salescur CURSOR FOR\
         SELECT distinct ssticode, SUM(ssqty)\
           FROM stocksales\
          WHERE ssprodno = l_bs.bsprodno\
            AND ssticode BETWEEN l_start_ticode AND l_end_ticode\
            AND sswhse = l_bs.bswhse\
            AND sstype = "S"\
          GROUP BY ssticode\
          ORDER BY ssticode\
        FOREACH salescur INTO l_ssticode, l_qty\
\
            LET l_count = l_count + 1\
\
            -- Increment total sales.\
            LET l_total_sales = l_total_sales + l_qty\
            IF std_calc_num_months(l_ssticode, l_end_ticode) <= 6 THEN\
                LET l_total_6 = l_total_6 + l_qty\
            END IF\
\
            -- Check if this months sales are the highest for the period.\
            IF l_qty > l_maxsales THEN\
                LET l_2ndmaxsales = l_maxsales\
                LET l_maxsales = l_qty\
            ELSE\
                -- Not highest sales, but may be the second highest sales.\
                IF l_qty > l_2ndmaxsales THEN\
                    LET l_2ndmaxsales = l_qty\
                END IF\
            END IF\
\
            -- Store the sales under the right month\
            LET l_mth = l_ssticode MOD 100\
            CASE l_mth\
                WHEN 1  LET l_rec.m1  = l_qty\
                WHEN 2  LET l_rec.m2  = l_qty\
                WHEN 3  LET l_rec.m3  = l_qty\
                WHEN 4  LET l_rec.m4  = l_qty\
                WHEN 5  LET l_rec.m5  = l_qty\
                WHEN 6  LET l_rec.m6  = l_qty\
                WHEN 7  LET l_rec.m7  = l_qty\
                WHEN 8  LET l_rec.m8  = l_qty\
                WHEN 9  LET l_rec.m9  = l_qty\
                WHEN 10 LET l_rec.m10 = l_qty\
                WHEN 11 LET l_rec.m11 = l_qty\
                WHEN 12 LET l_rec.m12 = l_qty\
            END CASE\
\
            -- Store the oldest ticode\
            LET l_ticode = l_ssticode\
\
        END FOREACH\
\
        ------ Setup rest of record -------------------------------------------------------------------------\
\
        LET l_rec.brcode = l_bs.bswhse\
        LET l_rec.brname = l_brname\
        LET l_rec.prodno = l_bs.bsprodno\
        LET l_rec.pmdesc = l_pmdesc\
        LET l_rec.grp    = l_grp\
\
        SELECT ludesc\
          INTO l_rec.stnname\
          FROM lukup\
         WHERE lutabid = "CA"\
           AND lucode = l_rec.grp\
        IF status = NOTFOUND THEN\
            LET l_rec.stnname = ""\
        END IF\
        LET l_rec.stnname = strip_comma(l_rec.stnname)\
\
        LET l_rec.subgrp = l_subgrp\
        LET l_stncat = l_rec.grp CLIPPED, l_rec.subgrp\
\
        SELECT ludesc\
          INTO l_rec.catname\
          FROM lukup\
         WHERE lutabid = "CB"\
           AND lucode = l_stncat\
        IF status = NOTFOUND THEN\
            LET l_rec.catname = ""\
        END IF\
        LET l_rec.catname = strip_comma(l_rec.catname)\
\
        LET l_rec.uom    = l_uom\
        LET l_rec.ratio  = l_ratio\
\
        LET l_rec.scheme  = l_bs.bsscheme\
        LET l_rec.mincurr = l_bs.bsminqty\
        LET l_rec.maxcurr = l_bs.bsmaxqty\
        LET l_rec.soh     = l_bs.bsohdqty\
        LET l_rec.son     = l_bs.bsonordqty\
        CALL std_get_mult_qty(l_bs.bswhse, l_bs.bssuppno , l_bs.bsprodno) RETURNING l_notused_c, l_rec.rmq\
\
        LET l_rec.mad    = l_bs.bsmad\
        LET l_rec.class  = l_bs.bsinvclass\
        \
        LET l_rec.scheme  = l_bs.bsscheme\
        LET l_rec.mincurr = l_bs.bsminqty\
        LET l_rec.maxcurr = l_bs.bsmaxqty\
        CALL std_get_prim_binloc(l_bs.bswhse, l_bs.bsprodno, FALSE)\
             RETURNING l_rec.binloc, l_notused\
\
        LET l_rec.seasonalFlag = l_bs.bsseasonal_product\
        LET l_rec.prodsuspend = l_bs.bsposuspend\
        LET l_rec.autoscheme = l_bs.bsautoscheme\
        LET l_rec.reviewFlag = std_getProductForecastReviewFlag(l_bs.bswhse, l_bs.bsprodno)\
\
        LET l_branchTypeCode = lib_get_branch_branchTypeCode(l_bs.bswhse)\
        SELECT pmkitflg\
          INTO l_kitflg\
          FROM product\
         WHERE pmprodno = l_bs.bsprodno\
        CALL std_get_best_supplier(l_bs.bsprodno, l_bs.bswhse, l_branchTypeCode, 1, l_kitflg, 1)\
            RETURNING l_data.*\
            \
        LET l_rec.prefSupplier = l_data.suppno\
        LET l_rec.prefSupplierName = lib_getSupplierName(l_data.suppno, l_data.suppstate)\
\
        IF lib_isOverseasSupplier(l_data.suppno, l_data.suppstate) THEN\
            LET l_rec.source = "IMPORT"\
        ELSE\
            LET l_rec.source = "LOCAL"\
            CALL lib_get_hub_branch(l_bs.bswhse, l_bs.bsprodno, l_bs.bsscheme) \
                RETURNING l_hubBranch\
            IF l_hubBranch IS NOT NULL THEN\
                LET l_rec.source = "HUB"\
            END IF\
        END IF        \
\
        -----------------------------------------------------------------------------------------------------\
        -- Fully Rebated D-Level: use the branch buying guide cost, or statecost if this is not found.\
\
        CALL std_get_cost(l_bs.bsprodno, l_bs.bswhse, "B", "", "")\
             RETURNING l_rec.fullreb, l_notused, l_notused, l_notused, l_notused_c, l_notused\
        IF l_rec.fullreb IS NULL THEN   LET l_rec.fullreb = 0   END IF\
\
        LET l_rec.sohvalue = l_rec.soh * l_rec.fullreb\
\
        -------- Output results to report -------------------------------------------------------------------\
\
        LET l_exec = l_rec.brcode,           ",",\
                     l_rec.brname,           ",",\
                     l_rec.prodno,           ",",\
                     l_rec.pmdesc,           ",",\
                     l_rec.grp,              ",",\
                     l_rec.stnname,          ",",\
                     l_rec.subgrp,           ",",\
                     l_rec.catname,          ","\
\
        LET l_mth = l_start_ticode MOD 100\
        FOR l_idx = 1 TO 12\
\
            CASE l_mth\
                WHEN 1  LET l_exec = l_exec CLIPPED, l_rec.m1,  ","\
                WHEN 2  LET l_exec = l_exec CLIPPED, l_rec.m2,  ","\
                WHEN 3  LET l_exec = l_exec CLIPPED, l_rec.m3,  ","\
                WHEN 4  LET l_exec = l_exec CLIPPED, l_rec.m4,  ","\
                WHEN 5  LET l_exec = l_exec CLIPPED, l_rec.m5,  ","\
                WHEN 6  LET l_exec = l_exec CLIPPED, l_rec.m6,  ","\
                WHEN 7  LET l_exec = l_exec CLIPPED, l_rec.m7,  ","\
                WHEN 8  LET l_exec = l_exec CLIPPED, l_rec.m8,  ","\
                WHEN 9  LET l_exec = l_exec CLIPPED, l_rec.m9,  ","\
                WHEN 10 LET l_exec = l_exec CLIPPED, l_rec.m10, ","\
                WHEN 11 LET l_exec = l_exec CLIPPED, l_rec.m11, ","\
                WHEN 12 LET l_exec = l_exec CLIPPED, l_rec.m12, ","\
            END CASE\
\
            LET l_mth = l_mth + 1\
            IF l_mth > 12 THEN\
                LET l_mth = 1\
            END IF\
\
        END FOR\
\
        SELECT obunrelqty\
          INTO l_obunrelqty             \
          FROM orderbank\
         WHERE obbrcode = l_bs.bswhse\
           AND obprodno = l_bs.bsprodno            \
        IF status != 0 THEN\
            LET l_obunrelqty = 0\
        END IF\
\
        LET l_date = TODAY\
        FOR l_idx = 1 TO 12 \
            CALL std_getSystemAndBranchMonthlyForecasts(l_rec.brcode, l_rec.prodno, l_date)\
                RETURNING l_monthlyForecast[l_idx].smsForecast, l_monthlyForecast[l_idx].branchForecast\
            LET l_date = date_unit(l_date, 1, "M")\
        END FOR\
\
        LET l_exec = l_exec CLIPPED,\
                     l_rec.class,            ",",\
                     l_rec.mad,              ",",\
                     l_rec.rmq,              ",",\
                     l_rec.scheme,           ",",\
                     l_rec.mincurr,          ",",\
                     l_rec.maxcurr,          ",",\
                     l_rec.soh,              ",",\
                     l_rec.son,              ",",\
                     l_rec.fullreb,          ",",\
                     l_rec.sohvalue,         ",",\
                     l_rec.uom,              ",",\
                     l_rec.ratio,            ",",\
                     l_rec.binloc,           ",",\
		             l_bs.bssys_mad3,	     ",",\
                     l_obunrelqty,           ",",\
                     l_rec.prefSupplier,     ",",\
                     l_rec.prefSupplierName, ",",\
                     l_rec.source,           ",",\
                     l_rec.seasonalFlag,     ",",\
                     l_rec.prodsuspend,      ",",\
                     l_rec.autoscheme,       ",",\
                     l_rec.reviewFlag\
                     \
        FOR l_idx = 1 TO 12 \
            LET l_exec = l_exec CLIPPED,     ",",\
                         l_monthlyForecast[l_idx].smsForecast\
        END FOR\
        FOR l_idx = 1 TO 12 \
            LET l_exec = l_exec CLIPPED,     ",",\
                         l_monthlyForecast[l_idx].branchForecast\
        END FOR\
\
        CALL std_writetext(l_exec)\
\
        LET l_report_count = l_report_count + 1\
\
    END FOREACH\
    CALL std_flushtext()\
\
    IF l_report_count = 0 THEN\
        CALL std_removeEmailStageFile(l_filename) RETURNING l_ok\
        ERROR " No records found. "\
        RETURN\
    END IF\
\
    ------ Email report to user -----------------------------------------------------------------------------\
\
    MESSAGE "Emailing Report..."\
    CALL std_emailAddAttachment(l_filename, "Stock Settings Data", "CSV", "Y")\
\
    LET l_email.to_address		 = p_uid.idemail\
    LET l_email.to_cc_email	     = NULL\
    LET l_email.to_name		     = p_mu.muname\
\
    CALL get_systemContactDetails(p_uid.idbranch)\
            RETURNING l_ok, l_email.from_address, l_email.from_name\
\
    LET l_email.subject		     = "Stock Settings Data Report"\
    LET l_email.message_filename = ""\
    LET l_email.body             = NULL\
    LET l_email.send_now		 = TRUE\
    #-- call 70734 -- should be set to E(email) instead of I(intranet)to access the file\
    LET l_email.delivery_type	 = "E"\
\
    CALL std_sendEmail(l_email.*, FALSE) \
    MESSAGE ""\
\
END FUNCTION\
\{*********************************************************************************************************************\}\
\{* strip_comma: Remove commas from the passed in string.                                                             *\}\
\{*                                                                                                                   *\}\
\{*   Pass - l_string: String to check, max 100 characters.                                                           *\}\
\{*                                                                                                                   *\}\
\{*   Returns - l_string: Checked string with commas removed.                                                         *\}\
\{*                                                                                                                   *\}\
\{*********************************************************************************************************************\}\
\
FUNCTION strip_comma(l_string)\
\
 DEFINE l_string                CHAR(100),\
        l_idx                   SMALLINT\
\
    FOR l_idx = 1 TO LENGTH(l_string)\
        IF l_string[l_idx] = "," THEN\
            LET l_string[l_idx] = " "\
        END IF\
    END FOR\
\
    RETURN l_string\
\
END FUNCTION\
\
\{*********************************************************************************************************************\}\
\
FUNCTION progress_dial(l_stage)\
\
 DEFINE l_stage     SMALLINT\
\
    CASE l_stage\
        WHEN 1  MESSAGE " Working (\\\\)"\
        WHEN 2  MESSAGE " Working (|)"\
        WHEN 3  MESSAGE " Working (/)"\
        WHEN 4  MESSAGE " Working (-)"\
    END CASE\
\
    LET l_stage = l_stage + 1\
    IF l_stage > 4 THEN\
        LET l_stage = 1\
    END IF\
\
    RETURN l_stage\
\
END FUNCTION\
\
\{*********************************************************************************************************************\}\
FUNCTION getDeliveryGroupCode(l_deliveryGroupId)\
\
    DEFINE l_deliveryGroupId    LIKE whse_delivery_group.wdg_id,\
           l_DeliveryGroupCode  LIKE whse_delivery_group.wdg_code\
\
    SELECT wdg_code\
      INTO l_DeliveryGroupCode\
      FROM whse_delivery_group\
     WHERE wdg_id = l_deliveryGroupId\
    IF status <> 0 THEN\
        LET l_DeliveryGroupCode = NULL\
    END IF\
\
    RETURN l_DeliveryGroupCode\
\
END FUNCTION\
\
\{*********************************************************************************************************************\}\
FUNCTION setupWhseRepldays(l_brcode, l_suppno)\
\
 DEFINE l_replenishDays                      t_replenishDays,\
        l_suppno                        LIKE repl_days.srd_repno,\
        l_salesPerson                   LIKE repl_days.srd_repno, \
        l_brcode                        LIKE branch.brcode \
\
    SELECT wdz_whse_code\
      INTO l_salesPerson\
        FROM whse_delivery_zone_branch, whse_delivery_zone\
       WHERE wdz_id = wdzb_delivery_zone_id\
         AND wdzb_branch_code = l_brcode\
         AND wdz_whse_code = l_suppno\
\
    IF STATUS <> 0 THEN                             \
        DECLARE salep_curs CURSOR FOR\
         SELECT sprepcode\
           FROM salesperson\
          WHERE spenabled = "Y"\
            AND spbrcode = l_brcode\
          ORDER By sprepcode\
        OPEN salep_curs\
        FETCH salep_curs INTO l_salesPerson\
        CLOSE salep_curs\
    END IF\
\
    LET l_replenishDays[1].mon = "N"                      \
    LET l_replenishDays[1].tue = "N"                      \
    LET l_replenishDays[1].wed = "N"                      \
    LET l_replenishDays[1].thu = "N"                      \
    LET l_replenishDays[1].fri = "N"                      \
    LET l_replenishDays[1].sat = "N"                      \
    LET l_replenishDays[1].sun = "N"                      \
    LET l_replenishDays[1].salesPerson = l_salesPerson\
    LET l_replenishDays[1].deliveryGroupId = NULL                     \
\
    RETURN l_replenishDays\
\
END FUNCTION\
\
\{*********************************************************************************************************************\}\
\
FUNCTION isNewReplenishDaysRecord(l_supplierProductGroupRepDays)\
\
 DEFINE l_supplierProductGroupRepDays           t_supplierProductGroupRepDays\
\
    IF l_supplierProductGroupRepDays.srd_suppno IS NOT NULL THEN\
               \
        IF l_supplierProductGroupRepDays.srd_repno IS NULL AND\
           l_supplierProductGroupRepDays.srd_mon IS NULL THEN\
            -- No Salesperson and one of the Repl Days is null\
            RETURN TRUE\
        END IF\
        \
    END IF\
\
    RETURN FALSE\
END FUNCTION\
\
\{*********************************************************************************************************************\}\
\
FUNCTION initNewReplenishDaysRecord(l_supplierProductGroupRepDays, l_defaultSalesperson)\
 DEFINE l_supplierProductGroupRepDays             t_supplierProductGroupRepDays,\
        l_defaultSalesperson                 LIKE salesperson.sprepcode\
\
    LET l_supplierProductGroupRepDays.srd_repno  = l_defaultSalesperson\
    LET l_supplierProductGroupRepDays.srd_mon    = "N"\
    LET l_supplierProductGroupRepDays.srd_tue    = "N"\
    LET l_supplierProductGroupRepDays.srd_wed    = "N"\
    LET l_supplierProductGroupRepDays.srd_thu    = "N"\
    LET l_supplierProductGroupRepDays.srd_fri    = "N"\
    LET l_supplierProductGroupRepDays.srd_sat    = "N"\
    LET l_supplierProductGroupRepDays.srd_sun    = "N"\
    LET l_supplierProductGroupRepDays.srd_status = "N"\
    LET l_supplierProductGroupRepDays.srd_balance= "N"\
\
\
    RETURN l_supplierProductGroupRepDays.*\
END FUNCTION\
\
}